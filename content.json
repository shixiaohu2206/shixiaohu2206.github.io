{"meta":{"title":"Utone","subtitle":"虎虎","description":"Utone|虎虎|博客|个人|utone","author":"Utone","url":"https://blog.utone.xyz","root":"/"},"posts":[{"tags":[],"title":"高亮字符","date":"2021/08/27","text":"酒店搜索联想下拉框，有一个高亮字符的需求，一个字条，对应多个高亮字符 eg: 上海海景房高亮词条为&lt;海景&gt;&lt;海景房&gt; =&gt; 上海海景房标签不嵌套，取高并集加标签 function hightlight(str, arr) &#123; str = `#$&#123;str.split('').join('#')&#125;#` arr = arr.map((item) =&gt; `#$&#123;item.split('').join('#')&#125;#`) let fill = new Array(str.length).fill(0) for (let i = 0; i &lt; str.length; i++) &#123; if (str[i] !== '#') continue for (let j = 0; j &lt; arr.length; j++) &#123; let length = arr[j].length if (str.substr(i, length) === arr[j]) &#123; fill[i]++ fill[i + length - 1]-- &#125; &#125; &#125; let res = '' fill.reduce((prev, item, key) =&gt; &#123; let total = prev + item if (prev === 0 &amp;&amp; total &gt; 0) &#123; res += `&lt;span&gt;$&#123;str[key]&#125;` &#125; else if (total === 0 &amp;&amp; item &lt; 0) &#123; res += `$&#123;str[key]&#125;&lt;/span&gt;` &#125; else if (item === 0) &#123; res += `$&#123;str[key]&#125;` &#125; return total &#125;, 0) return res.replace(/\\#/g, '') &#125;","permalink":"https://blog.utone.xyz/2021082717115/","photos":[]},{"tags":[],"title":"模拟实现instanceof","date":"2021/06/19","text":"定义用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上。 实现// left为实例函数 // right构造函数 function myInstacnce(left, right) &#123; if (typeof left !== 'object' || left === null) &#123; return false &#125; let leftProto = left.__proto__ let parentPrototype = right.prototype while (true) &#123; if (leftProto === parentPrototype) &#123; return true &#125; if (leftProto === null) &#123; return false &#125; leftProto = leftProto.__protype__ &#125; &#125;","permalink":"https://blog.utone.xyz/2021061957428/","photos":[]},{"tags":[],"title":"模拟实现call、apply","date":"2021/06/13","text":"介绍call() 方法在使用一个指定的 this 值和若干个指定的参数值的前提下调用某个函数或方法。 实现 将函数设为对象的属性 执行该函数 删除该函数 call/** * 模拟实现call * * 1. 改变this指向 * 2. 运行函数 * 3. 第一个参数不存在时，指向window */ Function.prototype.call2 = function (context) &#123; if (context === null || context === undefined) &#123; context = window &#125; else &#123; context = Object(context) || context &#125; context.__fn__ = this // ES6 // let args = Array.prototype.slice.call(arguments, 1) // let result = context.__fn__(...args) // ES5 var args = [] for (var i = 1, len = arguments.length; i &lt; len; i++) &#123; args.push('arguments[' + i + ']') &#125; // args会默认执行args.toString(),等同于args.join(',') // arguments[1],arguments[2] let result = eval('context.__fn__(' + args + ')') delete context.__fn__ return result &#125; apply实现基本与 call 一致，区别在于传参为数组 Function.prototype.apply2 = function (context, arr) &#123; if (context === null || context === undefined) &#123; context = window &#125; else &#123; context = Object(context) || context &#125; // 注意，此处的this是指的被调用的函数 context.func = this arr = arr || [] var res = eval('context.func(' + arr + ')') delete context.func return res &#125;","permalink":"https://blog.utone.xyz/2021061359111/","photos":[]},{"tags":[],"title":"React Diff","date":"2021/05/17","text":"Virtour Dom本质上是 JavaScript 对象，这个对象就是更加轻量级的对 DOM 的描述 Diff 算法目的比较新旧 Virtour DOM 中需要改变的部分，对并其进行原生 DOM 操作，尽可能的减少 DOM 操作。 Diff 算法三个策略即使使用最前沿的算法，全量对比 DOM 树，算法复杂程度也要为 O(n 3 )。为了降低算法复杂度，提高性能，React 做出以下预设： Web UI 开发中，节点跨层级的移动操作较少，忽略不计 相同类生成的组件有相似的树形结构、不同类生成的组件生成不同的树形结构 同一层级的子节点可以使用唯一的 Key 标识 Diff 算法三个粒度Tree Diff对树进行分层比较，两棵树只会对同一层节点进行比较。 Component Diff 不同类型的组件，标记为dirty component，就直接删除该组件及其所有子节点，并创建新节点及其子节点 同一类型的组件，React 允许用户使用shouldComponentUpdate来判断组件是否需要 diff Element Diff当节点处于同一层级时，React diff 提供三种节点操作 插入 INSERT_MARKUP 移动 MOVE_EXISTING 删除 REMOVE_NODE 移动 REMOVE_NODE对新集合的节点循环遍历，通过唯一 KEY 判断老集合中是否存在相同的节点。如果有相同的节点就执行移动操作。 将当前节点在老集合的 index 与 lastindex 比较，当 index 小于 lastindex 小时，则进行节点移动操作。这是一种顺序优化手段，lastIndex 一直在更新，表示访问过的节点在老集合中最右的位置（即最大的位置） 如果新集合中当前访问的节点 index 比 lastIndex 大，说明当前访问节点在老集合中就比上一个节点位置靠后，则该节点不会影响其他节点的位置，因此不用添加到差异队列中，即不执行移动操作，只有当访问的节点 index 比 lastIndex 小时，才需要进行移动操作 key 范例// 前 &lt;ul&gt; &lt;li key=\"one\"&gt;&lt;/li&gt; &lt;li key=\"two\"&gt;&lt;/li&gt; &lt;/ul&gt; // 后 &lt;ul&gt; &lt;li key=\"two\"&gt;&lt;/li&gt; &lt;li key=\"one\"&gt;&lt;/li&gt; &lt;/ul&gt; 上述的变化，只是li元素移动了位置，dom 节点属性没有变化 如果没有key，那么 React 会按照 2 的预设，同级比较，会删除one节点，重新生成two节点，新建 DOM 节点浪费的性能是巨大的。 有了key后，React 就可以知道，两个 li 节点只是移动了位置，那 DOM 节点就可以复用，做到最少的操作 DOM 参考 https://segmentfault.com/a/1190000017152570 https://zhuanlan.zhihu.com/p/20346379","permalink":"https://blog.utone.xyz/2021051711845/","photos":[]},{"tags":[],"title":"webpack","date":"2021/05/17","text":"介绍Webpack 是一个打包模块化 JavaScript 工具 webpack 与 gulp 的异同 都是前端构建工具 gulp 基于任务和流，找到文件后，对其做一系列链式操作。一些单一的、轻量化任务可又 gulp 来处理。例如打包编译 CSS 文件 gulp 需要开发者将构建过程拆分成多个Task，并合理分配控制Task的调用关系，而 webpack 只需要开发者找到开发入口，并清除不同的资源需要使用的Loader。 Loaderwebpack 本身只支持js和json文件。Loader 给予 webpack 处理其他类型文件的能力 module: &#123; rules: [ &#123; // 用正则去匹配要用该 loader 转换的 CSS 文件 test: /\\.css$/, use: ['style-loader', 'css-loader?minimize'] &#125; ] &#125; loader 中 use 的执行顺序是从后向前的。 &#39;css-loader?minimize&#39;中minimize已querystring的方式传参，告诉css-loader需要压缩文件 常用 loader style-loader 把 CSS 代码注入到 JavaScript 中，通过 DOM 操作去加载 CSS css-loader 使 CSS 文件以模块方式引入 less-loader 加载和编译 less 文件 sass-loader 加载和编译 sass/scss 文件 babel-loader 将 ES6+语法编译为 ES5 后浏览器才能解析 url-loader 用于加载图片，超过一定大小返回 data url pluginplugin 是用来扩展 webpack 功能的，通过在构建流程中注入钩子实现 常见 loader commons-chunk-plugin 提取公共代码 webpack 基本流程Webpack 的运行流程是一个串行的过程，从启动到结束会依次执行以下流程： 初始化参数：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数； 开始编译：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译； 确定入口：根据配置中的 entry 找出所有的入口文件； 编译模块：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理； 完成模块编译：在经过第 4 步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系； 输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会； 输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。 在以上过程中，Webpack 会在特定的时间点广播出特定的事件，插件在监听到感兴趣的事件后会执行特定的逻辑，并且插件可以调用 Webpack 提供的 API 改变 Webpack 的运行结果。 webpack 前端优化 压缩代码。删除多余的代码、注释、简化代码的写法等等方式。可以利用 webpack 的 UglifyJsPlugin 和 ParallelUglifyPlugin 来压缩 JS 文件， 利用 cssnano（css-loader?minimize）来压缩 css 静态资源 CDN 加速。在构建过程中，将引用的静态资源路径修改为 CDN 上对应的路径。可以利用 webpack 对于 output 参数和各 loader 的 publicPath 参数来修改资源路径 删除死代码（Tree Shaking）。将代码中永远不会走到的片段删除掉。可以通过在启动 webpack 时追加参数–optimize-minimize 来实现 提取公共代码 提高 webpack 构建速度 多入口情况下，使用 CommonsChunkPlugin 来提取公共代码 通过 externals 配置来提取常用库 利用 DllPlugin 和 DllReferencePlugin 预编译资源模块 通过 DllPlugin 来对那些我们引用但是绝对不会修改的 npm 包来进行预编译，再通过 DllReferencePlugin 将预编译的模块加载进来。 使用 Happypack 实现多线程加速编译 使用 webpack-uglify-parallel 来提升 uglifyPlugin 的压缩速度。 原理上 webpack-uglify-parallel 采用了多核并行压缩来提升压缩速度 https://segmentfault.com/a/1190000015883378","permalink":"https://blog.utone.xyz/2021051715317/","photos":[]},{"tags":[],"title":"React Context","date":"2021/05/12","text":"介绍Context 提供了一个无需为每层组件手动添加 props，就能在组件树间进行数据传递的方法 何时使用: Context 主要应用场景在于很多不同层级的组件需要访问同样一些的数据。请谨慎使用，因为这会使得组件的复用性变差。 16.3 新版本 APIReact.createContextconst &#123; Provider, Consumer &#125; = React.createContext(defaultValue) 创建一个 Context 对象。当 React 渲染一个订阅了这个 Context 对象的组件，这个组件会从组件树中离自身最近的那个匹配的 Provider 中读取到当前的 context 值。 Context.Provider&lt;MyContext.Provider value=&#123;/* 某个值 */&#125;&gt; 每个 Context 对象都会返回一个 Provider React 组件，它允许消费组件订阅 context 的变化。 Class.contextTypeclass MyClass extends React.Component &#123; componentDidMount() &#123; let value = this.context; /* 在组件挂载完成后，使用 MyContext 组件的值来执行一些有副作用的操作 */ &#125; componentDidUpdate() &#123; let value = this.context; /* ... */ &#125; componentWillUnmount() &#123; let value = this.context; /* ... */ &#125; render() &#123; let value = this.context; /* 基于 MyContext 组件的值进行渲染 */ &#125; &#125; MyClass.contextType = MyContext; 挂载在 class 上的 contextType 属性会被重赋值为一个由 React.createContext() 创建的 Context 对象。这能让你使用 this.context 来消费最近 Context 上的那个值。你可以在任何生命周期中访问到它，包括 render 函数中。 Context.Consumer&lt;MyContext.Consumer&gt; &#123;value =&gt; /* 基于 context 值进行渲染*/&#125; &lt;/MyContext.Consumer&gt; 一个 React 组件可以订阅 context 的变更，这让你在函数式组件中可以订阅 context。 建议React 官方不建议使用大量 context,尽管他可以减少逐层传递,但是当组件结构复杂的时候,我们并不知道 context 是从哪里传过来的;而且 context 是一个全局变量,全局变量正是导致应用走向混乱的罪魁祸首. React 通信 父组件向子组件通信，使用 props 子组件向父组件通信，回调函数、自定义事件 跨级组件通信，层层传递 props、context 没有嵌套关系组件通信，自定义事件","permalink":"https://blog.utone.xyz/2021051221164/","photos":[]},{"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://blog.utone.xyz/tags/JavaScript/"}],"title":"模拟实现原型链继承","date":"2021/02/15","text":"介绍只有函数对象才有属性prototype 每个实例对象都有一个私有属性__proto__，指向它的构造函数的原型对象prototype 每个实例对象共享原型对象上属性、方法。也就是实例对象从原型对象上继承了属性、方法 基于原型链实现继承当访问对象中的方法、属性时，会先搜寻对象本身，若存在则停止搜寻。若不存在，则会去搜寻该对象的原型，以及该对象的原型的原型，依次层层向上搜寻，如果找不到，则返回undefined 按照上述原理，就可以将父类的属性、方法，设置为子类的原型，那么子类就相当于继承了父类的属性、方法，并且子类可以重写属性、方法（可以称为”属性遮蔽”） 寄生组合式继承function Parent(name) &#123; this.name = name &#125; Parent.prototype.sayName = function () &#123; console.log(this.name) &#125; function Child(name) &#123; // 仅使用call，只继承了父类构造函数的属性、方法 // 父类构造函数的原型对象中的属性、方法，都没有继承过来 Parent.call(this, name) &#125; // 所以子类的原型还需要继承父类的原型 // 使用Object.create生成一个新对象，这样子类的原型与父类的原型就不会共享 // 在子类原型上修改属性、方法，不会影响到父类 Child.prototype = Object.create(Parent.prototype) // 使子类的constructor指向正确 Child.prototype.constructor = Child let ins = new Child('Child') console.log(ins.name) // 'Child' ins.sayName() // 'Child' 封装一下继承方法// 子类需要在函数体中执行，Parent.call(this) // 这样才能继承父类构造函数中的属性、方法 function inherit(child, parent) &#123; parent.call(child) child.prototype = Object.create(parent.prototype) child.prototype.constructor = child return child &#125; 问题 为什么属性定义在构造函数上，方法需要定义在构造函数的原型上? 查看了阮一峰的Javascript 继承机制的设计思想一文，有以下感悟： 属性、方法定义在哪里并非强制。定义在原型上，纯粹是为了共享，对于所有实例都会共享的属性、方法，就可以定义在原型上 一般在实际开发中，属性一般不需要共享，一般都是子类在 new 时，去复写父类属性 方法一般是繁琐庞大，且可以复用，那每次实例就复制父类的所有方法，就会造成内存方面的问题 为什么要使用Object.create(Parent.prototype)，来新生成一个对象，达到寄生的作用? 因为直接让父类的原型赋值给子类的原型（Child.prototype = Parent.prototype），这样就导致原型共享。想要在子类的原型上添加属性、方法，就会影响到父类，所以使用寄生作用，避免影响父类 // Object.create的模拟实现 function Create(o) &#123; function F() &#123;&#125; F.prototype = 0 return new F() &#125;","permalink":"https://blog.utone.xyz/2021021528410/","photos":[]},{"tags":[],"title":"PWA","date":"2021/02/12","text":"PWA1. 介绍 PWA（Progressive Web App）渐进式增强 WEB 应用, 即渐进式 web 应用。PWA 本质上是 web 应用，目的是通过多项新技术，在安全、性能、体验等方面给用户原生应用的体验。而且无需像原生应用那样繁琐的下载、安装、升级等操作。 打开chrome://inspect/#service-workers可查看 chrome 当前运行的 service worker 2. 核心功能、特性 PWA 中包含的核心功能及特性如下： Web App Manifest Service Worker Cache API 缓存 Push&amp;Notification 推送与通知 Background Sync 后台同步 响应式设计 2.1 特性 基于 HTTPS 环境，这是构建 PWA 的硬性前提 是一个独立的 worker 线程，独立于当前网页进程，有自己独立的 worker context 可拦截 HTTP 请求和响应，可缓存文件，缓存的文件可以在网络离线状态时取到 能向客户端推送消息 不能直接操作 DOM 异步实现，内部大都是通过 Promise 实现 3. Service Worker 生命周期 注册–安装–激活 3.1 注册 告诉浏览器 serviceworkerJS 文件存放在什么位置，浏览器下载、解析、执行。 if ('serviceWorker' in navigator) &#123; window.addEventListener('load', function () &#123; navigator.serviceWorker .register('/sw.js') .then(function (registration) &#123; // 注册成功 console.log('ServiceWorker registration successful with scope: ', registration.scope) &#125;) .catch(function (err) &#123; // 注册失败:( console.log('ServiceWorker registration failed: ', err) &#125;) &#125;) &#125; 3.2 安装 注册结束后，触发 install 事件，进行安装。 var CACHE_VERSION = 'sw_v8' var CACHE_FILES = ['/js/jquery/min.js', '/js/zui/min.js', '/js/chanzhi.js'] self.addEventListener('install', function (event) &#123; event.waitUntil(caches.open(CACHE_VERSION).then(cache =&gt; cache.addAll(CACHE_FILES))) &#125;) 3.3 激活 当安装成功后，serviceworker 就会激活，这时就会处理 activate 事件回调 (提供了更新缓存策略的机会)。并可以处理功能性的事件 fetch (请求)、sync (后台同步)、push (推送)。 self.addEventListener('activate', function (event) &#123; event.waitUntil( caches.keys().then(function (keys) &#123; return Promise.all( keys.map(function (key, i) &#123; if (key !== CACHE_VERSION) &#123; return caches.delete(keys[i]) &#125; &#125;) ) &#125;) ) &#125;) 3. Service Worker 缓存功能 安装时，service worker 将我们指定的静态资源进行缓存（即预缓存）,与此同时，service worker 还可以拦截 HTTP 请求相应，做到动态缓存 self.addEventListener('fetch', function (event) &#123; event.respondWith( caches.match(event.request).then(function (response) &#123; if (response) &#123; return response &#125; var requestToCache = event.request.clone() return fetch(requestToCache).then(function (response) &#123; if (!response || response.status !== 200) &#123; return response &#125; var responseToCache = response.clone() caches.open(CACHE_VERSION).then(function (cache) &#123; cache.put(requestToCache, responseToCache) &#125;) return response &#125;) &#125;) ) &#125;) PWA 添加横幅，增加用户使用率 https://lavas.baidu.com/doc/engage-retain-users/add-to-home-screen/app-install-banners https://github.com/electron-react-boilerplate/electron-react-boilerplate","permalink":"https://blog.utone.xyz/202102124606/","photos":[]},{"tags":[],"title":"Event-Loop事件循环","date":"2020/10/30","text":"Event Loop为了协调事件（event），用户交互（user interaction），脚本（script），渲染（rendering），网络（networking）等，用户代理（user agent）必须使用事件循环（event loops）。（3 月 29 修订） JavaScript 引擎又称为 JavaScript 解释器，是 JavaScript 解释为机器码的工具，分别运行在浏览器和 Node 中。而根据上下文的不同，Event loop 也有不同的实现：其中 Node 使用了 libuv 库来实现 Event loop; 而在浏览器中，html 规范定义了 Event loop，具体的实现则交给不同的厂商去完成。 所以，浏览器的 Event loop 和 Node 的 Event loop 是两个概念 宏任务(macro)task（又称之为宏任务），可以理解是每次执行栈执行的代码就是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈中执行）。 浏览器为了能够使得 JS 内部(macro)task 与 DOM 任务能够有序的执行，会在一个(macro)task 执行结束后，在下一个(macro)task 执行开始前，对页面进行重新渲染，流程如下： (macro)task-&gt;渲染-&gt;(macro)task-&gt;... (macro)task 主要包含：script(整体代码)、setTimeout、setInterval、I/O、UI 交互事件、postMessage、MessageChannel、setImmediate(Node.js 环境) 微任务microtask（又称为微任务），可以理解是在当前 task 执行结束后立即执行的任务。也就是说，在当前 task 任务后，下一个 task 之前，在渲染之前。 所以它的响应速度相比 setTimeout（setTimeout 是 task）会更快，因为无需等渲染。也就是说，在某一个 macrotask 执行完后，就会将在它执行期间产生的所有 microtask 都执行完毕（在渲染前）。 microtask 主要包含：Promise.then、MutaionObserver、process.nextTick(Node.js 环境) 运行机制在事件循环中，每进行一次循环操作称为 tick，每一次 tick 的任务处理模型是比较复杂的，但关键步骤如下： 执行一个宏任务（栈中没有就从事件队列中获取） 执行过程中如果遇到微任务，就将它添加到微任务的任务队列中 宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行） 当前宏任务执行完毕，开始检查渲染，然后 GUI 线程接管渲染 渲染完毕后，JS 线程继续接管，开始下一个宏任务（从事件队列中获取） EventLoop，哪些是宏任务、微任务宏任务 setTimeout setInterval I/O setImmediate (node) requestAnimationFrame (你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行)https://juejin.im/post/5b6020b8e51d4535253b30d1 微任务 process.nextTick (node) MutationObserver Promise 面试题问以下代码执行顺序 // 今日头条面试题 async function async1() &#123; console.log('async1 start') await async2() console.log('async1 end') &#125; async function async2() &#123; console.log('async2') &#125; console.log('script start') setTimeout(function () &#123; console.log('settimeout') &#125;) async1() new Promise(function (resolve) &#123; console.log('promise1') resolve() &#125;).then(function () &#123; console.log('promise2') &#125;) console.log('script end') script start async1 start async2 promise1 script end async1 end promise2 settimeout setTimeout(() =&gt; &#123; console.log('timer1') Promise.resolve().then(function () &#123; console.log('promise1') &#125;) &#125;, 0) setTimeout(() =&gt; &#123; console.log('timer2') Promise.resolve().then(function () &#123; console.log('promise2') &#125;) &#125;, 0) // 浏览器 time1 promise1 time2 promise2 // Node time1 time2 promise1 promise2 await 做了什么从字面意思上看 await 就是等待，await 等待的是一个表达式，这个表达式的返回值可以是一个 promise 对象也可以是其他值。 很多人以为 await 会一直等待之后的表达式执行完之后才会继续执行后面的代码，实际上 await 是一个让出线程的标志。await 后面的表达式会先执行一遍，将 await 后面的代码加入到 microtask 中，然后就会跳出整个 async 函数来执行后面的代码。 async function async1() &#123; console.log('async1 start') await async2() console.log('async1 end') &#125; 等价于 async function async1() &#123; console.log('async1 start') Promise.resolve(async2()).then(() =&gt; &#123; console.log('async1 end') &#125;) &#125; await async2();之后的 console.log(‘async1 end’);，也会塞入到微任务中 总结 同一个上下文下，微任务优先于宏任务执行 setTimeout 属于宏任务执行，Promise 属于微任务，而 async 和 await 其实是 geneorator 的语法糖,实质上最后返回的也是 promise 引用浏览器的执行顺序是在一开始会通篇扫描整个脚本,生成主执行栈,用于执行同步任务.而异步任务会加入至浏览器的任务队列中.当执行栈为空,就会去 Task 队列中(任务队列)取出需要执行的代码放入执行栈中去执行。而 Task 队列中,我们又再之前提及到分:微任务和宏任务微任务的优先级大于宏任务,所以在执行栈为空的时候,首先会去执行 Micortask(微任务)队列,执行完毕后再去取 Macrotask(宏任务)队列去执行栈中执行,一次执行一个,再去检查 Micortask(微任务),若存在则执行 Microtask,若没有则取下一个 Macrotask 任务继续执行,直至为空。 微任务和宏任务在 Node 的执行顺序 Node 10 以前： 执行完一个阶段的所有任务执行完 nextTick 队列里面的内容然后执行完微任务队列的内容Node 11 以后：和浏览器的行为统一了，都是每执行一个宏任务就执行完微任务队列。","permalink":"https://blog.utone.xyz/2020103016638/","photos":[]},{"tags":[],"title":"Flex弹性布局","date":"2020/10/30","text":"说明Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。 容器属性 flex-wrap flex-direction flex-flow 是 flex-direction 属性和 flex-wrap 属性的简写形式，默认值为 row nowrap。 justify-content align-items aligh-content 定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用 容器属性定义容器内的子元素的布局 项目属性 order 定义项目的排列顺序。数值越小，排列越靠前，默认为 0。 flex-grow 属性定义项目的放大比例，默认为 0，即如果存在剩余空间，也不放大。 flex-shrink 如果所有项目的 flex-shrink 属性都为 1，当空间不足时，都将等比例缩小。如果一个项目的 flex-shrink 属性为 0，其他项目都为 1，则空间不足时，前者不缩小。负值对该属性无效。默认为 1 flex-basis 属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为 auto，即项目的本来大小。 flex 是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。 aligh-self 属性允许单个项目有与其他项目不一样的对齐方式，可覆盖 align-items 属性。默认值为 auto，表示继承父元素的 align-items 属性，如果没有父元素，则等同于 stretch。 flex 简写flex: 1 === flex: 1 1 0%; flex 属性可以指定 1 个，2 个或 3 个值。 单值语法: 值必须为以下其中之一: 一个无单位数(): 它会被当作&lt;flex-grow&gt;的值。 一个有效的宽度(width)值: 它会被当作 &lt;flex-basis&gt;的值。 关键字 none，auto 或 initial. 双值语法: 第一个值必须为一个无单位数，并且它会被当作 &lt;flex-grow&gt; 的值。第二个值必须为以下之一： 一个无单位数：它会被当作 的值。 一个有效的宽度值: 它会被当作 的值。 三值语法: 第一个值必须为一个无单位数，并且它会被当作 的值。 第二个值必须为一个无单位数，并且它会被当作 的值。 第三个值必须为一个有效的宽度值， 并且它会被当作 的值。 flex 特殊值 initial 元素会根据自身宽高设置尺寸。它会缩短自身以适应 flex 容器，但不会伸长并吸收 flex 容器中的额外自由空间来适应 flex 容器 。相当于将属性设置为”flex: 0 1 auto”。 auto 元素会根据自身的宽度与高度来确定尺寸，但是会伸长并吸收 flex 容器中额外的自由空间，也会缩短自身来适应 flex 容器。这相当于将属性设置为 “flex: 1 1 auto”. none 元素会根据自身宽高来设置尺寸。它是完全非弹性的：既不会缩短，也不会伸长来适应 flex 容器。相当于将属性设置为”flex: 0 0 auto”。 flex 计算宽度问left和right宽度多少 px？ * &#123; padding: 0; margin: 0; &#125; .container &#123; width: 600px; height: 300px; display: flex; &#125; .left &#123; flex: 1 2 500px; background: red; &#125; .right &#123; flex: 2 1 400px; background: blue; &#125; 由 CSS 可以得知，容器的总宽度为600px，子元素的flex-basis相加超出容器宽度300px 那接下来就计算这300px怎么由子元素平分缩小 注意：两个子元素的flex-shrik分别为2和1，但实际浏览器并不是按照2:1来平分300px缩小的 首先计算子元素的flex-basic与flex-shrik的乘积，并求和 left: 2 * 500 = 1000 right: 1 * 400 = 400 total: 1000 + 400 = 1400 计算缩小占比，再与多出的300px，求出缩小数值 left: (1000 / 1400) * 300 = 214.2857142857143 right: (400 / 1400) * 300 = 85.71428571428571 再用flex-basic相减，得出最终宽度 left: 500 - 214.2857142857143 = 285.7142857142857 right: 400 - 85.71428571428571 = 314.2857142857143","permalink":"https://blog.utone.xyz/2020103023020/","photos":[]},{"tags":[],"title":"圣杯、双飞翼布局","date":"2020/09/30","text":"要点 两侧宽度固定，中间宽度自适应 中间部分在 DOM 结构上优先，以便先行渲染 允许三列中的任意一列成为最高列 圣杯布局 设置container的左右padding，为左右元素预留空间 设置left的margin-left为100%，使其与 center 在同一行 设置left为relative，left偏移量为负的自身宽度，使其到达左侧预留位置 设置right的margin-right为负的自身宽度，使其到达右侧预留位置 DOM 结构使用container将整体包裹，dom 结构更加直观 &lt;div class=\"header\"&gt;&lt;/div&gt; &lt;div class=\"container\"&gt; &lt;div class=\"center column\"&gt;center&lt;/div&gt; &lt;div class=\"left column\"&gt;left&lt;/div&gt; &lt;div class=\"right column\"&gt;right&lt;/div&gt; &lt;/div&gt; &lt;div class=\"footer\"&gt;&lt;/div&gt; &lt;style&gt; body &#123; min-width: 400px; &#125; .header, .footer &#123; width: 100%; height: 100px; background-color: khaki; &#125; .container &#123; overflow: hidden; padding-left: 100px; padding-right: 200px; &#125; .column &#123; float: left; &#125; .center &#123; width: 100%; background-color: mediumpurple; &#125; .left &#123; width: 100px; margin-left: -100%; /* 失败百分比 */ background-color: lightblue; position: relative; left: -100px; &#125; .right &#123; width: 200px; margin-right: -200px; /* 使用px，而不是百分比 */ background-color: lightseagreen; &#125; &lt;/style&gt; 双飞翼布局container只将center包裹，作为鸟的身体 left和right在两侧，作为鸟的翅膀 双飞翼这个词很形象 DOM 结构只使用div包裹center &lt;div class=\"header\"&gt;&lt;/div&gt; &lt;div class=\"container column\"&gt; &lt;div class=\"center\"&gt;center&lt;/div&gt; &lt;/div&gt; &lt;div class=\"left column\"&gt;left&lt;/div&gt; &lt;div class=\"right column\"&gt;right&lt;/div&gt; &lt;div class=\"footer\"&gt;&lt;/div&gt; 将colum提升到container上 设置colum左浮动 设置center的 margin，为左右流出空间 设置left的margin-left为-100%，将left放置左侧预留位置 设置right的margin-left为负的自身长度，将right放置右侧预留位置 body 的min-width就是左右元素的宽度和300px &lt;style&gt; body &#123; min-width: 300px; &#125; .header, .footer &#123; width: 100%; height: 100px; background-color: khaki; &#125; .footer &#123; clear: both; &#125; .column &#123; float: left; &#125; .container &#123; width: 100%; &#125; .center &#123; margin-left: 100px; margin-right: 200px; background-color: mediumpurple; &#125; .left &#123; width: 100px; margin-left: -100%; background-color: lightblue; &#125; .right &#123; width: 200px; margin-left: -200px; background-color: lightseagreen; &#125; &lt;/style&gt; 比对 圣杯布局，DOM 结构更加自然合理，但使用了相对定位，代码稍多点 双飞翼，CSS 代码简洁，允许的页面的最小宽度也小点 兼容性很好 Flex 实现 设置left的项目属性order为-1，将其放置最左侧 flex-grow设置为0，不放大 flex-shrink设置为0，不缩小 flex-basis设置为固定宽度 DOM 结构与圣杯布局一致 &lt;div class=\"header\"&gt;&lt;/div&gt; &lt;div class=\"container\"&gt; &lt;div class=\"center\"&gt;center&lt;/div&gt; &lt;div class=\"left\"&gt;left&lt;/div&gt; &lt;div class=\"right\"&gt;right&lt;/div&gt; &lt;/div&gt; &lt;div class=\"footer\"&gt;&lt;/div&gt; &lt;style&gt; .header, .footer &#123; width: 100%; height: 100px; background-color: khaki; &#125; .container &#123; display: flex; &#125; .center &#123; width: 100%; background-color: mediumpurple; &#125; .left &#123; order: -1; flex: 0 0 100px; background-color: lightblue; &#125; .right &#123; flex: 0 0 200px; background-color: lightseagreen; &#125; &lt;/style&gt;","permalink":"https://blog.utone.xyz/2020093063178/","photos":[]},{"tags":[],"title":"模拟实现throttle节流","date":"2020/08/17","text":"throttle 节流 执行触发事件，每隔一段时间后，就触发一次真实函数 场景 浏览器 scroll 时，滚动时，隔断时间触发一次回调 实现根据时间戳 触发 throttle 后，会立即执行一次函数 假设 wait 为 1 秒，那么在 1.2 秒时停止触发，则函数就不会再触发 function throttle(fun, wait) &#123; let time, prev = 0 return function() &#123; let context = this let args = arguments let now = +New Date() if (now - prev &gt; wait) &#123; fun.apply(context, args) prev = now &#125; &#125; &#125; 使用定时器 触发 throttle 后，不会立即执行一次函数 假设 wait 为 1 秒，那么在 1.2 秒时停止触发，函数会在 2 秒时，再执行一次函数 function throttle() &#123; let time return function () &#123; let context = this let args = arguments if (!time) &#123; time = setTimeout(function () &#123; time = null fun.apply(context, args) &#125;, wait) &#125; &#125; &#125;","permalink":"https://blog.utone.xyz/2020081716539/","photos":[]},{"tags":[],"title":"模拟实现new","date":"2020/07/17","text":"介绍new 运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象类型之一 可以访问构造函数中的属性 可以访问构造函数 prototype 的属性 MDN 创建一个空的简单 JavaScript 对象（即{}）； 链接该对象（即设置该对象的构造函数）到另一个对象 ； 将步骤 1 新创建的对象作为 this 的上下文 ； 如果该函数没有返回对象，则返回 this。 功能返回对象时，实例只能访问到返回对象的属性 function Otaku(name, age) &#123; this.strength = 60 this.age = age return &#123; name: name, habit: 'Games' &#125; &#125; var person = new Otaku('Kevin', '18') console.log(person.name) // Kevin console.log(person.habit) // Games console.log(person.strength) // undefined console.log(person.age) // undefined 返回基本类型时，实例可以访问构造函数的属性 function Otaku(name, age) &#123; this.strength = 60 this.age = age return 'handsome boy' &#125; var person = new Otaku('Kevin', '18') console.log(person.name) // undefined console.log(person.habit) // undefined console.log(person.strength) // 60 console.log(person.age) // 18 // 返回函数时，函数作为返回值 function Otaku2(name, age) &#123; this.strength = 60 this.age = age return function cb() &#123; return &#123; value: 1 &#125; &#125; &#125; console.log(new Otaku2('kevin', '18')) // function cb() 实现功能： 新建一个对象实例 将对象实例的__proto__指向构造函数的prototype 运行构造函数 判断结果为对象，返回对象，不为对象，返回新建的对象实例 // 第二版的代码 function objectFactory() &#123; var obj = &#123;&#125;, Constructor = [].shift.call(arguments) obj.__proto__ = Constructor.prototype var ret = Constructor.apply(obj, arguments) return (typeof ret === 'object' || typeof ret === 'function') &amp;&amp; ret !== null ? ret : obj &#125;","permalink":"https://blog.utone.xyz/2020071721804/","photos":[]},{"tags":[],"title":"模拟实现bind","date":"2020/06/30","text":"MDN 描述 bind() 方法创建一个新的函数，在 bind() 被调用时，这个新函数的 this 被指定为 bind() 的第一个参数，而其余参数将作为新函数的参数，供调用时使用。 一个绑定函数也能使用 new 操作符创建对象：这种行为就像把原函数当成构造器。提供的 this 值被忽略，同时调用时的参数被提供给模拟函数。 Function.prototype.bind2 = function (context) &#123; if (typeof this !== 'function') &#123; throw new Error('Function.prototype.bind - what is trying to be bound is not callable') &#125; var self = this var args = Array.prototype.slice.call(arguments, 1) var fNOP = function () &#123;&#125; var fBound = function () &#123; var bindArgs = Array.prototype.slice.call(arguments) return self.apply(this instanceof fNOP ? this : context, args.concat(bindArgs)) &#125; fNOP.prototype = this.prototype fBound.prototype = new fNOP() return fBound &#125; /** * 手写bind * * 实现功能 * 1. 返回一个函数 * 2. 第一个参数作为返回函数运行时的this指向 * 3. 后续参数，可以作为返回函数的参数，并且可以bind时传入，还可以在运行时传入 * 4. 返回函数作为构造函数时，第一个参数作为this指向失效，但后续参数仍然可以当做返回函数的参数 */ Function.prototype.bind = Function.prototype.bind || function (context) &#123; if (typeof this !== 'function') &#123; throw new Error('Function.prototype.bind - what is trying to be bound is not callable') &#125; var self = this let args = Array.prototype.slice(arguments, 1) let fun = function () &#123; let bindArgs = Array.prototype.slice(arguments) // 返回的函数是可以作为构造函数的 // 使用instanceof判断，如果作为构造函数,apply需要执行本身 return self.apply(this instanceof fun ? this : context, args.concat(bindArgs)) &#125; // 使用一个空函数，来作为prototype的中转 // 避免作为构造函数时，修改实例的prototype，会改变self的prototype fun.prototype = Object.create(self.prototype) // let nop = function () &#123;&#125; // nop.prototype = self.prototype // fun.prototype = new nop() return fun &#125;","permalink":"https://blog.utone.xyz/2020063062877/","photos":[]},{"tags":[],"title":"模拟实现debounce防抖","date":"2020/06/17","text":"debounce 防抖 触发事件N时间后，才会真正执行绑定事件的函数 this 指向 事件回调的 Event 参数 场景 浏览器 resize 时 按钮发送多次请求时 实现function debounce(fun, wait) &#123; let time = null return function () &#123; let context = this let args = arguments if (time) clearTimeout(time) time = setTimeout(fun.apply(context, args), wait) &#125; &#125; 使用 // func为真正需要执行的函数 container.onmousemove = debounce(func, 1000) 增加功能 上述防抖的执行时机为触发事件的N时间后。现在将需求改为触发事件时，就立即执行 增加一个取消功能 function debounce(fun, wait, immediate) &#123; let time, result let debounce = function () &#123; let context = this let args = arguments if (time) clearTimeout(time) if (immadiate) &#123; let callNow = !time time = setTimeout(function () &#123; time = null &#125;, wait) if (callNow) &#123; result = fun.apply(context, args) &#125; &#125; else &#123; time = setTimeout(fun.apply(context, args), wait) &#125; return result &#125; debounce.cancel = function () &#123; clearTimeout(time) time = null &#125; return debounce &#125;","permalink":"https://blog.utone.xyz/2020061760189/","photos":[]},{"tags":[],"title":"模拟实现ajax","date":"2020/05/13","text":"AJAXAJAX（Asynchronous JavaScript And XML ）是一种使用 XMLHttpRequest 技术构建更复杂，动态的网页的编程实践 XMLHttpRequestXMLHttpRequest(XHR)对象用户与服务器交互。通过XHR可以在不刷新页面的情况下请求指定 url，获取数据。这允许网页在不影响用户操作的情况下，更新页面的局部数据 readyState 0 UNSENT 代理被创建，但尚未调用 open() 方法。 1 OPENED open() 方法已经被调用。 2 HEADERS_RECEIVED send() 方法已经被调用，并且头部和状态已经可获得。 3 LOADING 下载中； responseText 属性已经包含部分数据。 4 DONE 下载操作已完成。 实现function ajax(method, url, data) &#123; return new Promise((resolve, reject) =&gt; &#123; data = data || &#123;&#125; method = (method || 'GET').toUpperCase() let xhr if (XMLHttpRequest) &#123; xhr = new XMLHttpRequest() &#125; else &#123; xhr = new ActiveXObject('Micosoft.XMLHTTP') &#125; if (method === 'GET') &#123; xhr.open(method, url + formatData(data)) xhr.send(null) &#125; else &#123; xhr.open(method, url) xhr.setRequestHeader('Content-type', 'application/json') xhr.send(JSON.stringify(data)) &#125; // 与xhr.onload一样，readyState为4时会触发onload xhr.onreadystatechange = function () &#123; console.log(xhr) if (xhr.readyState === 4) &#123; let status = xhr.status if ((status &gt;= 200 &amp;&amp; status &lt; 300) || status === 304) &#123; return resolve(JSON.parse(xhr.responseText)) &#125; else &#123; return reject(xhr.statusText) &#125; &#125; &#125; function formatData(data) &#123; let arr = [] let v = `_v=$&#123;new Date().getTime()&#125;` if (Object.keys(data).length === 0) &#123; return `?$&#123;v&#125;` &#125; else &#123; for (let i in data) &#123; arr.push(`$&#123;encodeURIComponent(i)&#125;=$&#123;encodeURIComponent(data[i])&#125;`) &#125; arr.push(v) return '?' + arr.join('&amp;') &#125; &#125; &#125;) &#125;","permalink":"https://blog.utone.xyz/2020051334921/","photos":[]},{"tags":[],"title":"闭包","date":"2020/04/25","text":"定义能够访问另一个函数作用域变量的函数 基本类型的值一般存在栈内存中引用类型的值一般存在堆内存中 优点 变量常驻内存，对于实现某些业务很有帮助，比如计数器之类的。 架起了一座桥梁，让函数外部访问函数内部变量成为可能。 私有化，一定程序上解决命名冲突问题，可以实现私有变量。 缺点变量常驻在内存中，其占用内存无法被 GC 回收，导致内存溢出 用途 读取函数内部的变量 让这些变量的值始终保持在内存中 方便调用上下文的局部变量。可用于代码封装 作用域var a = 10; (function () &#123; console.log(a) a = 5 console.log(window.a) var a = 20; console.log(a) &#125;)() underfined 10 20 局部变量var a = 20;在当前作用域会变量声明提升机制，所以为underfined","permalink":"https://blog.utone.xyz/202004257415/","photos":[]},{"tags":[{"name":"async","slug":"async","permalink":"https://blog.utone.xyz/tags/async/"},{"name":"await","slug":"await","permalink":"https://blog.utone.xyz/tags/await/"}],"title":"优雅处理 async/await 异常","date":"2019/11/13","text":"前言async/await 是 ES7 中的新特性，方便开发者以同步代码书写异步调用，避免回调地狱 但是对于这样的代码，怎样处理异常？ 目前从网上查询的解决方法，大致有两种 try catchtry catch 捕获是非常常见捕获同步代码异常的方法，它可以轻松捕捉到async/await 的异常 async function func() &#123; // 通过try catch捕获异常调用的异常 try &#123; const data = await Api.get() // 同步写法、异步调用 if (!data) &#123; console.log('no data') &#125; &#125; catch (err) &#123; console.log(err) &#125; &#125; 假如一个 async 声明的函数中有多次的异步调用，那就需要在每一个在每个异步调用的代码块上，都包一层 try catch，注意，是每一个 当然也可以在最外层包一层 try catch，但是这样一旦有异常抛出，异常代码下方代码就不会再执行，会造成代码逻辑上的错误 以上， 这明显就有悖于我们用 async/await 的初衷：使代码更加简洁 Go Lang从 Go 语言处理异常得到的灵感。 Go 语言在执行一段代码后，会赋值两个变量 一个是正常运行结果，一个是运行时的异常 若异常为 null，就没有错误需要处理 f, err := os.Open(\"filename.txt\") if err != nil &#123; return err &#125; await-to-jsasync/await实际上是 promise 的语法糖。再从上述 Go 语言处理异常的灵感，得出另一种解决方案 使用一个包装函数，包装函数中执行 Promise 代码 若正常则返回结果，同时返回的 err 对象 为 null 若运行中有异常抛出，用 catch 捕获异常，返回的 err 对象为捕获到的异常 再使用 ES6 的解构赋值，可以非常方便的实现上述思路 /** * 优雅捕获async/await异常 (简洁版await-to-js) * * @param &#123;*&#125; promise */ const to = function(promise) &#123; return promise.then(data =&gt; [null, data]).catch(err =&gt; [err, undefined]) &#125; // 解构赋值 const [data, err] = await to(func()) // err有值，说明有异常 if (err) &#123; console.log('func 有异常抛出') &#125; 推荐使用 scopsy 贡献的 await-to-js npm 包 /** * @param &#123; Promise &#125; promise * @param &#123; Object= &#125; errorExt - Additional Information you can pass to the err object * @return &#123; Promise &#125; */ export function to&lt;T, U = Error&gt;(promise: Promise&lt;T&gt;, errorExt?: object): Promise&lt;[U | null, T | undefined]&gt; &#123; return promise .then&lt;[null, T]&gt;((data: T) =&gt; [null, data]) .catch&lt;[U, undefined]&gt;((err: U) =&gt; &#123; if (errorExt) &#123; Object.assign(err, errorExt) &#125; return [err, undefined] &#125;) &#125; export default to","permalink":"https://blog.utone.xyz/2019111331593/","photos":[]},{"tags":[{"name":"Chart","slug":"Chart","permalink":"https://blog.utone.xyz/tags/Chart/"}],"title":"主题新增百度统计图表功能","date":"2019/11/13","text":"前言主题新增了百度统计相关信息展示，统计数据都来自于百度统计 若使用该功能，需要先接入百度统计 功能介绍新增展示标签，可以随意在 markdown、模板引擎文件中添加指定类名的标签 新增 class 为site_date的标签，展示建站时间 新增 class 为site_from的标签，展示站点建立日期 新增 class 为site_pv的标签，展示站点从建立日期到目前的 PV（浏览量） 新增 class 为site_uv的标签，展示站点从建立日期到目前的 UV（访客数） 新增 id 为line-chart的标签，展示站点近七天的线状图 新增 id 为doughnut-chart的标签，展示站点从建立日期到目前 PV（浏览量）的饼状图 具体样式请查看本站 关于 本站于 &lt;code class=\"site_from\"&gt;&lt;/code&gt; 接入百度站点，建站已 &lt;code class=\"site_date\"&gt;&lt;/code&gt; 天 截止到目前，整站访问次数 &lt;code class=\"site_pv\"&gt;&lt;/code&gt;、访问人数 &lt;code class=\"site_uv\"&gt;&lt;/code&gt; &lt;canvas id=\"doughnut-chart\" width=\"100\" height=\"45\"&gt;&lt;/canvas&gt; &lt;canvas id=\"line-chart\" width=\"100\" height=\"45\"&gt;&lt;/canvas&gt; 使用方法在根目录的_config.yml配置文件中，新增以下参数 #百度统计 baidu_tongji: site_from: '2019/7/26' site_id: '' access_token: '' 获取 Access Token调用了百度统计相关的接口，需要获取百度统计的 Access Token 获取 token 的教程在百度统计 管理-&gt;数据导出服务页面中，有详细的解说 大致分为以下三步： 登陆 百度开发者中心控制台，点击 创建工程，获取 API Key 和 Secret Key 访问 右键复制链接地址，按照提示登陆，之后页面会展示code，记下这个code 访问 右键复制链接地址，之后页面就是展示 access_token 和 refresh_token 上述的链接地址中的 CLIENT_ID 对应 API KeyCLIENT_SECRET 对应 Secret KeyREDIRECT_URI 写死为 oob oob 为默认的 redirect_uri，避免没有服务器，无法接收回调数据，而将信息直接在页面中展示","permalink":"https://blog.utone.xyz/2019111314005/","photos":["/2019111314005/1.jpg"]},{"tags":[{"name":"HEXO-THEME-HUHU","slug":"HEXO-THEME-HUHU","permalink":"https://blog.utone.xyz/tags/HEXO-THEME-HUHU/"}],"title":"主题使用文档","date":"2019/11/08","text":"介绍 简单、突出文字，是开发的初衷 一个在 Hexo 博客上开发的主题，主题会持续更新 近日服务器搬迁完成，腾出时间来完善一下博客文档 安装git clone https://github.com/shixiaohu2206/hexo-theme-huhu.git themes/hexo-theme-huhu 在项目根目录操作以上命令，并修改根目录下的 _config.yml 中的 theme 为 hexo-theme-huhu 本主题需要安装shelljs，因为 requiresJS 打包时，需要执行 bash 命令 npm install --save shelljs 站内搜索目前主题只支持自生成搜索文件的方式，因为依赖第三方站内搜索，始终不是很稳定的赶脚，而且会加载许多第三方的服务文件，导致博客首屏加载慢 安装安装hexo-generator-json-content插件，用于生成站内搜索生成文件 npm install --save hexo-generator-json-content 在根目录下的 _config.yml 中新增配置，如下: #https://github.com/alexbruno/hexo-generator-json-content jsonContent: dateFormat: YYYY/MM/DD pages: false posts: tags: true title: true date: true text: true permalink: true photos: true file: content.json 新建 about 页面about 页面没有单独 layout，直接以 markdown 渲染 hexo new page \"about\" 新建 tags、categories、friends 页面tags、categories、friends 有单独的 layout，所以新增命令后，需要在对应的文件中新增 layout 参数 hexo new page \"tags\" hexo new page \"friends\" hexo new page \"categories\" 请自行添加，例如： --- layout: tags --- friends 友链在根目录下的 _config.yml 中新增配置，例如： friends: - name: Don Lex time: '2019-10-12' url: 'https://www.donlex.cn/' logo: 'https://www.donlex.cn/images/avatar.png' intro: '码农' Google 相关配置如果使用 GTM 统计、Goole 站点、Google 广告等，则在根目录配置 _config.yml 中添加配置 #google-site-verification 添加在meta信息中 google_site_verification: '' #google gtm gtm_id: '' #google gtm google_ad_client: '' Baidu 相关配置主题新加了一个百度统计图表功能，使用方法见链接 使用百度站点、百度联盟、百度统计等功能，在根目录配置 _config.yml 中添加配置 # 百度站点验证码 baidu_site_verification: '' #百度联盟验证 baidu_union_verify: '' #百度统计 baidu_tongji: site_from: '2019/7/26' site_id: '' access_token: 'xxxxx' 代码高亮本主题支持 highlight.js 官方的 css，highlight.js 官网看中哪个颜色搭配，复制 css 样式替换themes\\huhu\\source\\style\\highlight.styl 新增 hljs 参数，并设为 trye，不然无法使用 highlight.js 官方的 css highlight: enable: true hljs: true #新增hljs参数，并设为true，不然无法使用highlight.js 官方的 css line_number: false #暂不支持行号 auto_detect: false #这一项也关闭，若开启有可能报错 tab_replace: 文章评论支持两种方案，二选一 valine 畅言 valine 评论官网教程，在根目录配置 _config.yml 中添加 #valine评论 valine: API_ID: '' API_KEY: '' 畅言评论官网教程，在根目录配置 _config.yml 中添加 #畅言评论 changyan: appid: '' conf: '' RSS安装插件hexo-generator-feed npm install --save hexo-generator-feed 在根目录配置 _config.yml 中添加 #rss feed: type: atom path: atom.xml limit: 20 hub: content: content_limit: 140 content_limit_delim: '' order_by: -date icon: icon.png 置顶#卸载官方插件 npm uninstall hexo-generator-index --save #安装插件 npm install hexo-generator-index-pin-top --save 在 markdown 文件的 Front-matter，新增 top: 1即可，top 值越大，越靠前展示 主题在列表页增加了置顶的小图标，具体样式查看虎虎博客 兼容性使用了 Flex 布局，不支持 IE8 自定义其他的自定义，修改也很方便，比如更换打赏二维码、Follow 地址，都在主题的配置中themes\\huhu\\_config.yml，各位大佬请自行修改","permalink":"https://blog.utone.xyz/2019110815531/","photos":["/images/huhu.png"]},{"tags":[{"name":"docker","slug":"docker","permalink":"https://blog.utone.xyz/tags/docker/"},{"name":"gogs","slug":"gogs","permalink":"https://blog.utone.xyz/tags/gogs/"},{"name":"egg","slug":"egg","permalink":"https://blog.utone.xyz/tags/egg/"}],"title":"docker及docker-compose 安装部署记录","date":"2019/11/01","text":"前言腾讯云服务器将要到期，在忙着服务器搬迁的事，博客也荒废了挺久 使用 Docker 的原因 学习新的部署方式 方便服务器搬迁，快速部署，不会浪费大量时间在环境配置上 安装 dokcer安装 Docker CE（社区版） 官方教程 https://docs.docker.com/install/linux/docker-ce/centos/ 安装 DOCKER CE需要一个 Centos7 以上版本的环境 卸载老版本 sudo yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-engine 安装最新版本的 Docker CE 和 containerd $ sudo yum install docker-ce docker-ce-cli containerd.io 启动 Docker $ sudo service docker start 验证 docker 是否安装成功 $ sudo docker -v 粗心大意的报错拉取镜像时报错 Cannot connect to the Docker daemon at unix:///var/run/docker.sock. 是因为没启动 docker… service docker start 安装 docker-compose docker-compose 是 docker 提供的命令行工具，用来定义和运行多个容器组成的应用。不要每次手动敲启动容器命令。 推荐使用 pip 安装 docker-compose，因为 pip 可以为你自动对应版本问题 // 安装pip yum -y install epel-release yum -y install python-pip // 升级 pip install --upgrade pip // 如果报这个error，执行下面命令 ERROR: Cannot uninstall 'requests'. It is a distutils installed project and thus we cannot accurately determine which files belong to it which would lead to only a partial uninstall. // 安装requests pip install --ignore-installed requests // 安装docker-compose pip install docker-compose 构建 docker-compose.yml容器之间的通信困扰了挺久，现版本不建议使用link来连接两个容器，link后续废弃，使用networks即可，进入容器内后，ping 另一个容器名，就可以查看另一个容器 IP，所以这边我只在 nginx 容器中暴露 80 端口，其他容器需要访问，直接在 nginx 做转发 启动了三个应用 nginx：做容器域名端口的转发 gogs：因为公司内网对 github 做了拦截，所以使用 gogs 做中间代码版本库 egg-nuxt：后台项目，实现 egg.js + nuxt.js + vue.js 的服务端渲染架子 下方为docker-compose.yml范例，仅供参考 version: '3.7' #使用docker-compose的版本 services: nginx: image: *****/nginx #使用的镜像 container_name: 'nginx' tty: true restart: always depends_on: #依赖容器 - gogs - egg-nuxt ports: #端口映射 - '80:80' - '443:443' networks: - bridge gogs: image: *****/gogs container_name: 'gogs' restart: always networks: - bridge egg-nuxt: image: *****/egg-nuxt container_name: 'egg-nuxt' restart: always networks: - bridge networks: bridge: Nginx 转发配置因为每次重装应用后，docker 容器内的网络 IP 会改变，目前有两种方案： 使用容器名作为 host，因为容器名是定义好的，不会改变 用 docker 静态 IP ，是容器 IP 固定 server &#123; listen 80; server_name api.com; location / &#123; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Host $http_host; proxy_set_header X-Nginx-Proxy true; proxy_set_header Connection \"\"; client_max_body_size 100m; #上传文件大小限制 proxy_pass http://api:7001; &#125; &#125; docker 及 docker-compose 常用命令都是自己常用的命令 docker、nginx// 查看当前文件大小 du -sh * // 查看所有端口开放 netstat -ano netstat -lp // 查看nginx目录 ps -ef | grep nginx // 查看正在运行的容器 docker ps // 查看所有的容器 docker ps -a // 查看镜像 docker images // 删除所有未被容器使用的镜像 docker image prune -a // -d 后台运行 // -it 在容器内可执行shell // -p 端口映射 // --name 容器名 docker run -d --name=demo -p 7001:7001 gogs // 进入容器内可执行shell docker exec -it gogs /bin/bash // 使用本地容器生成镜像 docker commit -a username -m 'commit' 611f10799671 *****/nginx:v1 docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]] // --rm 是删除构建过程中，产生的临时镜像 // -t 是指定镜像名称及标识 // . 代表默认选择Dockerfile为构建文件 docker build --rm -t egg-nuxt:v1.0 . // 登陆Docker docker login // push镜像到Docker Hub docker push [OPTIONS] NAME[:TAG] // 查看日志 docker logs *****/nginx docker-compose需要在docker-compose.yml同级目录执行，命令与 docker 命令基本一致 // 后台启动应用 docker-compose up -d // 删除删除所有容器,镜像 docker-compose down Docker hub、github 自动部署 在 github 项目的根目录添加Dockerfile文件，这样 Docker hub 就可以根据Dockerfile文件来自动构建 使用现成的镜像固然很方便，但是有些配置还是需要自定义，所以现成镜像为基本，在上方做一些自定义，再生成新的镜像，就是最好的方式。Docker hub 提供了在云端自动构建镜像的能力。Docker hub 上的配置就不说了，网络上很多 在自动构建 Nodejs 应用的过程遇到以下几点问题： 使用 node 原生镜像，构建的包很大，解压后超过了 1GB 构建时间长，基本要在 4 分钟以上 使用 node alpine 镜像，用 git 拉取 github 代码比较困难 解决方案 使用 node alpine 镜像，体积小，构建速度快 使用 ADD 命令，远程拉取 github 项目的 zip 包 Dockerfile范例，仅供参考 #使用alpine nodejs镜像、体积更小 FROM node:10-alpine #新建工作目录 RUN mkdir -p /project #下载项目代码 ADD https://github.com/********/egg-nuxt-framework/archive/master.zip /project/ #解压、安装包、编译TS RUN cd /project &amp;&amp; unzip master.zip &amp;&amp; cd egg-nuxt-framework-master &amp;&amp; npm install &amp;&amp; npm run ci #进入到app目录下 WORKDIR /project/egg-nuxt-framework-master #对外暴露的端口 EXPOSE 7001 #程序启动脚本 CMD [\"npm\", \"start\"] 期间遇到的问题 在 push 代码到 gogs 后，gogs 的 post-receive 钩子会再 push 代码到 github，本来使用 ssh，需要在 gogs 容器中生成密钥提交到 github 上。生成后，在测试时发现以下报错 Host key verification failed. remote: fatal: Could not read from remote repository. 这是因为 ssh 密钥不是 git 用户下生成的，艹，这个地方花了很久才解决，而且调试过程中还遇到了两次…想锤死自己 gogs 容器中没有装vim，只有vi，所以打开 ssh 密钥时，是一行展示的，无法复制，可以使用scp命令复制到另一台机器上，使用 vim 打开 push 代码不一定要 ssh 密钥，使用 github token 也可以实现，且更加方便在 github 上生成 token git remote add github https://&#123;token&#125;@github.com/*****/egg-nuxt-framework.git git push -f github master push 代码到 gogs 时，一直报错 413 error: RPC failed; HTTP 413 curl 22 The requested URL returned error: 413 Request Entity Too Large 是因为 gogs 是用 nginx 做转发，nginx 对上传文件有默认限制 在 nginx 配置中新增client_max_body_size 100m;解决 默认 1m 最后使用 docker 部署，走了许多弯路，选择合适镜像、容器之间通信就花了挺久，对于一个陌生的领域，确实需要花挺多精力来学习。 共勉","permalink":"https://blog.utone.xyz/201911012681/","photos":["/201911012681/1.png"]},{"tags":[{"name":"TravisCI","slug":"TravisCI","permalink":"https://blog.utone.xyz/tags/TravisCI/"},{"name":"Hexo","slug":"Hexo","permalink":"https://blog.utone.xyz/tags/Hexo/"}],"title":"使用Travis CI持续集成Hexo博客","date":"2019/09/10","text":"Travis CI 教程和讲解，可以查看阮一峰老师的《持续集成服务 Travis CI 教程》 前言使用 Travis CI 的原因，也很简单，就是在写完博客的时候，不希望在本地构建、发布，于是想到能不能在远端构建发布? Travis CI 正好满足了这个要求，Github 上开源的仓库，都可以使用它进行持续集成 需求 上传 Hexo 博客源码，自动部署到相应的静态 Pages 仓库上 本站对国内、国外做了 CNAME 区分，国内访问 Coding Pages，国外访问 Github Pages（有利于百度 SEO，因为百度不收录 Github Pages），这样的话，Hexo 构建发布时需要发布到两个静态 Pages 仓库上 登陆 Travis CI使用 Github 账户登陆 Travis CI，登陆完成后，打开设置，找到 Hexo 源码仓库，打开开关，这样 Travis CI 就可以监听到这个仓库的变动 完成以上操作，接下来就是编写 Travis CI 配置文件了 新建配置文件 在 Hexo 项目根目录新建.travis.yml 字段名定义都很清晰，就是将每次部署命令，写在配置文件中，Travis CI 检测到仓库变动后， 会去读取.travis.yml命令，一步一步执行，直到部署成功 # 语言 language: node_js # node版本 node_js: - 8 # 指定缓存模块 cache: directories: - node_modules # 监听分支 branches: only: - master # 下载主题 before_install: - git clone https://github.com/shixiaohu2206/hexo-theme-huhu.git themes/huhu install: - npm install script: - hexo clean - hexo generate after_script: - git config user.name \"Utone\" - git config user.email \"asjdr123@163.com\" - sed -i \"s/&#123;GITHUB_TOKEN&#125;/$&#123;GITHUB_TOKEN&#125;/g\" ./_config.yml - sed -i \"s/&#123;TENCENT_TOKEN&#125;/$&#123;TENCENT_TOKEN&#125;/g\" ./_config.yml - hexo deploy # 通知 notifications: email: - asjdr123@163.com on_success: change on_failure: always 获取 token Travis CI 构建部署时是没有权限来 push 代码的，所以这里用 Token 来 push 代码需要 https 格式 git 地址 Github 的 Personal access tokens 不需要&lt;token-name&gt;，直接使用 token 即可 git push https://&lt;token&gt;@giturl Coding 的项目令牌，需要&lt;token-name&gt; git push https://&lt;token-name&gt;:&lt;token&gt;@giturl Github 获取 Access Token新建一个 Personal access tokens，成功后，记录下来，Github 的 Access Token 只会显示一次，后续就无法查看 Coding 获取项目令牌需要将推送至代码仓库勾选上 确认新增后，点击查看密码，记录令牌用户名、令牌密码 (token) Travis CI 新增环境变量token 属于敏感数据，一定不能暴露在开源仓库中 所以我们需要在 Travis CI 新增环境变量（对外不可见），这样构建时，用环境变量来替换 hexo 的配置文件中占位符，再来执行hexo d Hexo 源码根目录下_config.yml，修改deploy配置 # Deployment ## Docs: https://hexo.io/docs/deployment.html deploy: - type: git repository: https://&#123;GITHUB_TOKEN&#125;@giturl branch: master - type: git repository: https://&#123;TENCENT_USERNAME&#125;:&#123;TENCENT_TOKEN&#125;@giturl branch: master Travis CI 新增环境变量 新增 NAME 与deploy配置中占位符GITHUB_TOKEN保持一致，将获取的 token，对应填入，点击保存 修改.travis.yml，用sed命令，将上述保存的环境变量替换占位符 after_script: - git config user.name \"Utone\" - git config user.email \"asjdr123@163.com\" - sed -i \"s/&#123;GITHUB_TOKEN&#125;/$&#123;GITHUB_TOKEN&#125;/g\" ./_config.yml - sed -i \"s/&#123;TENCENT_TOKEN&#125;/$&#123;TENCENT_TOKEN&#125;/g\" ./_config.yml - hexo deploy 完成部署终于不用在本地执行hexo deploy了，写完博文，直接 push 代码即可 Travis CI 部署有可能会失败，可以查看Job log查看运行日志 感谢 Travis CITravis CI 专为开源项目做远端持续集成，非常感谢 从Travis CI官网搬来的团队合影（侵删）","permalink":"https://blog.utone.xyz/2019091039107/","photos":["/2019091039107/ci.png"]},{"tags":[{"name":"Swiftype","slug":"Swiftype","permalink":"https://blog.utone.xyz/tags/Swiftype/"}],"title":"Hexo博客添加Swiftype站内搜索","date":"2019/08/31","text":"选择 hexo-generator-json-content，Hexo 插件，生成博文 JSON 文件，前端启动搜索时，请求文件内容，来检索内容。需要自行写前端逻辑、样式。不依赖第三方服务，稳定可靠 Swiftype，提供一整套站内搜索服务，引入官方的脚本即可。有免费 14 天试用期。试用期过后，听说还可以用，但内容更新较慢，速度也变慢 注册看其他教程有说必须要使用工作邮箱注册才可以，但是我使用了 Google 账号登陆，亲测可行 创建引擎 创建一个新的引擎，输入博客网址后，开始抓取网站内容，抓取时间不定，大概十几分钟到一个小时左右 自定义设置可以自定义配置，如样式、展示方式、搜索字段。一般选用默认就够用了 展示方式有两种：一种是搜索启动按钮悬浮在底部，一种需要在页面中增加一个input输入框（我选择了这种方式） 启动按钮悬浮在底部 安装代码 等抓取结束后，点击左侧的Install Search后，就可以获取安装代码了 注意：右侧的红框中的代码，直接用鼠标复制，不是完全的代码。打开 F12 后，发现下方还有剩余的代码（没有滚动条的 textarea，坑爹） 将安装代码复制到body标签内 &lt;script type=\"text/javascript\"&gt; (function(w,d,t,u,n,s,e)&#123;w['SwiftypeObject']=n;w[n]=w[n]||function()&#123; (w[n].q=w[n].q||[]).push(arguments);&#125;;s=d.createElement(t); e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e); &#125;)(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st'); _st('install','xxxxx-xxxxxx-xxxxxx','2.0.0'); &lt;/script&gt; 在页面中合适的位置，新增一个class=&quot;st-default-search-input&quot;的input元素 &lt;input type=\"text\" class=\"st-default-search-input\" /&gt; 大功告成","permalink":"https://blog.utone.xyz/2019083151629/","photos":["/2019083151629/7.jpg"]},{"tags":[{"name":"倒影","slug":"倒影","permalink":"https://blog.utone.xyz/tags/倒影/"}],"title":"倒影","date":"2019/08/22","text":"","permalink":"https://blog.utone.xyz/2019082232923/","photos":["/2019082232923/1.jpg"]},{"tags":[{"name":"楼顶","slug":"楼顶","permalink":"https://blog.utone.xyz/tags/楼顶/"}],"title":"楼顶","date":"2019/08/04","text":"公司楼顶真的是风景极美的地方，适合放风~ SOHO 楼顶全景 SOHO 的喷泉 装了一波 B~ 同事偷拍","permalink":"https://blog.utone.xyz/2019080423894/","photos":["/2019080423894/1.jpg"]},{"tags":[{"name":"天空","slug":"天空","permalink":"https://blog.utone.xyz/tags/天空/"}],"title":"天空","date":"2019/07/20","text":"媳妇拍的不错～～ 这样的风景，看着就很舒服～ 一个天空，不同景色","permalink":"https://blog.utone.xyz/2019072041993/","photos":["/2019072041993/1.jpeg"]},{"tags":[{"name":"git","slug":"git","permalink":"https://blog.utone.xyz/tags/git/"}],"title":"git服务器端钩子","date":"2019/07/09","text":"pre-receive处理来自客户端的推送操作时，最先被调用的脚本是 pre-receive。 它从标准输入获取一系列被推送的引用。如果它以非零值退出，所有的推送内容都不会被接受。 你可以用这个钩子阻止对引用进行非快进（non-fast-forward）的更新，或者对该推送所修改的所有引用和文件进行访问控制。 updateupdate 脚本和 pre-receive 脚本十分类似，不同之处在于它会为每一个准备更新的分支各运行一次。 假如推送者同时向多个分支推送内容，pre-receive 只运行一次，相比之下 update 则会为每一个被推送的分支各运行一次。 它不会从标准输入读取内容，而是接受三个参数：引用的名字（分支），推送前的引用指向的内容的 SHA-1 值，以及用户准备推送的内容的 SHA-1 值。 如果 update 脚本以非零值退出，只有相应的那一个引用会被拒绝；其余的依然会被更新。 post-receivepost-receive 挂钩在整个过程完结以后运行，可以用来更新其他系统服务或者通知用户。 它接受与 pre-receive 相同的标准输入数据。 它的用途包括给某个邮件列表发信，通知持续集成（continous integration）的服务器，或者更新问题追踪系统（ticket-tracking system） —— 甚至可以通过分析提交信息来决定某个问题（ticket）是否应该被开启，修改或者关闭。 该脚本无法终止推送进程，不过客户端在它结束运行之前将保持连接状态，所以如果你想做其他操作需谨慎使用它，因为它将耗费你很长的一段时间。","permalink":"https://blog.utone.xyz/201907097636/","photos":[]},{"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://blog.utone.xyz/tags/JavaScript/"}],"title":"PWA简单介绍","date":"2019/06/14","text":"介绍 PWA（Progressive Web App）, 即渐进式 web 应用。PWA 本质上是 web 应用，目的是通过多项新技术，在安全、性能、体验等方面给用户原生应用的体验。而且无需像原生应用那样繁琐的下载、安装、升级等操作。 打开chrome://inspect/#service-workers可查看 chrome 当前运行的 service worker 核心技术 Service Worker 是 PWA 的核心技术 特性 基于 HTTPS 环境，这是构建 PWA 的硬性前提 是一个独立的 worker 线程，独立于当前网页进程，有自己独立的 worker context 可拦截 HTTP 请求和响应，可缓存文件，缓存的文件可以在网络离线状态时取到 能向客户端推送消息 不能直接操作 DOM 异步实现，内部大都是通过 Promise 实现 Service Worker 生命周期 注册–安装–激活 注册 告诉浏览器 serviceworkerJS 文件存放在什么位置，浏览器下载、解析、执行。 if ('serviceWorker' in navigator) &#123; window.addEventListener('load', function() &#123; navigator.serviceWorker .register('/sw.js') .then(function(registration) &#123; // 注册成功 console.log('ServiceWorker registration successful with scope: ', registration.scope) &#125;) .catch(function(err) &#123; // 注册失败:( console.log('ServiceWorker registration failed: ', err) &#125;) &#125;) &#125; 安装 注册结束后，触发 install 事件，进行安装。 var CACHE_VERSION = 'sw_v8' var CACHE_FILES = ['/js/jquery/min.js', '/js/zui/min.js', '/js/chanzhi.js'] self.addEventListener('install', function(event) &#123; event.waitUntil(caches.open(CACHE_VERSION).then(cache =&gt; cache.addAll(CACHE_FILES))) &#125;) 激活 当安装成功后，serviceworker 就会激活，这时就会处理 activate 事件回调 (提供了更新缓存策略的机会)。并可以处理功能性的事件 fetch (请求)、sync (后台同步)、push (推送)。 self.addEventListener('activate', function(event) &#123; event.waitUntil( caches.keys().then(function(keys) &#123; return Promise.all( keys.map(function(key, i) &#123; if (key !== CACHE_VERSION) &#123; return caches.delete(keys[i]) &#125; &#125;) ) &#125;) ) &#125;) Service Worker 缓存功能 安装时，service worker 将我们指定的静态资源进行缓存（即预缓存）,与此同时，service worker 还可以拦截 HTTP 请求相应，做到动态缓存 self.addEventListener('fetch', function(event) &#123; event.respondWith( caches.match(event.request).then(function(response) &#123; if (response) &#123; return response &#125; var requestToCache = event.request.clone() return fetch(requestToCache).then(function(response) &#123; if (!response || response.status !== 200) &#123; return response &#125; var responseToCache = response.clone() caches.open(CACHE_VERSION).then(function(cache) &#123; cache.put(requestToCache, responseToCache) &#125;) return response &#125;) &#125;) ) &#125;) PWA 添加横幅，增加用户使用率 https://lavas.baidu.com/doc/engage-retain-users/add-to-home-screen/app-install-banners https://github.com/electron-react-boilerplate/electron-react-boilerplate","permalink":"https://blog.utone.xyz/2019061422121/","photos":[]},{"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://blog.utone.xyz/tags/JavaScript/"}],"title":"代码规范","date":"2019/06/14","text":"代码规范优点 由于项目开发多成员协作问题，程序员开发习惯不同，项目的不断迭代会导致代码质量问题、代码维护问题、可读性问题的出现，所以好的校验工具可以确保一个项目遵循代码规范、避免一些常见的隐患出现 Prettier 配置文档地址: https://prettier.io/docs/en/options.html 在项目根目录下添加prettier.config.js module.exports = &#123; printWidth: 80, // 一行最大多少字符 tabWidth: 2, // tab占用的字符数 semi: false, // 在语句末尾添加分号 useTabs: false, // 是否使用tab代替空格 singleQuote: true, // 是否使用单引号 jsxSingleQuote: false, // jsx是否使用单引号 jsxBracketSameLinte: true, // 在多行JSX元素最后一行的末尾添加 &gt; 而使 &gt; 单独一行（不适用于自闭和元素） trailingComma: 'none', // 在任何可能的多行中输入尾逗号 bracketSpacing: true, // 在对象字面量声明所使用的的花括号后（&#123;）和前（&#125;）输出空格 jsxBracketSameLine: false, // 看官网 arrowParens: 'avoid', // 为单行箭头函数的参数添加圆括号, /** * endOfLine: \"&lt;auto|lf|crlf|cr&gt;\" * \"auto\" - 维护现有的行结尾（通过查看第一行之后使用的内容来标准化一个文件中的混合值） * \"lf\"- Line Feed only（\\n），在Linux和macOS以及git repos内部很常见 * \"crlf\"- 回车符+换行符（\\r\\n），在Windows上很常见 * \"cr\"- 仅限回车符（\\r），很少使用 */ endOfLine: 'auto' // 文件行结尾风格 &#125; Eslint 配置文档地址：https://cn.eslint.org/docs/rules/ 在项目跟目录下添加.eslintrc.json module.exports = &#123; parser: 'babel-eslint', env: &#123; browser: true, node: true, commonjs: true, amd: true, es6: true, mocha: true &#125;, extends: ['eslint:recommended', 'plugin:react/recommended'], // 使用Eslint官方规则推荐 globals: &#123; Atomics: 'readonly', SharedArrayBuffer: 'readonly' &#125;, parserOptions: &#123; ecmaVersion: 2018, sourceType: 'module' &#125;, rules: &#123; semi: 0, // 要求或禁止使用分号代替 ASI 'no-undef': 2, // 禁用未声明的变量，除非它们在 /*global */ 注释中被提到 'jsx-quotes': 0, // 强制在 JSX 属性中一致地使用双引号或单引号 quotes: [0, 'single', 'double'], // 强制使用一致的反勾号、双引号或单引号 'no-multi-spaces': 2, // 禁止使用多个空格 'comma-spacing': [2, &#123; before: false, after: true &#125;], // 强制在逗号前后使用一致的空格 'comma-dangle': 2, // 要求或禁止末尾逗号 'valid-jsdoc': 0, // 强制使用有效的 JSDoc 注释 indent: ['error', 2], // 强制使用一致的缩进 'arrow-parens': 0, // 要求箭头函数的参数使用圆括号 'object-curly-spacing': 0, // 强制在大括号中使用一致的空格 'spaced-comment': [2, 'always'], // 强制在注释中 // 或 /* 使用一致的空格 'one-var-declaration-per-line': 2, // 要求或禁止在变量声明周围换行 'default-case': 2, // 要求 switch 语句中有 default 分支 'no-new-wrappers': 2, // 禁止对 String，Number 和 Boolean 使用 new 操作符 eqeqeq: 1, // 要求使用 === 和 !== 'no-alert': 1, // 禁用 alert、confirm 和 prompt 'no-console': 1, // 禁用 alert、confirm 和 prompt 'no-eval': 1, // 禁用 eval() 'no-implied-eval': 1, // 禁止使用类似 eval() 的方法 'eol-last': 2, // 要求或禁止文件末尾存在空行 'no-multiple-empty-lines': 2, // 禁止出现多行空行 'no-var': 2, // 要求使用 let 或 const 而不是 var 'prefer-const': 2 // 要求使用 const 声明那些声明后不再被修改的变量 &#125; &#125;","permalink":"https://blog.utone.xyz/2019061435373/","photos":[]},{"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://blog.utone.xyz/tags/JavaScript/"}],"title":"总结笔记20190614","date":"2019/06/14","text":"解决 chrome network 中出现provisional headers are shown，导致跨域时，查看不了 cookie 的携带情况 解决方法https://stackoverflow.com/questions/21177387/caution-provisional-headers-are-shown-in-chrome-debugger chrome://flags/ Disable site isolation Enable network service Runs network service in-process less 的函数 data-uri，可以将图片编译成 base64 格式，图片过大时，不生效，最大尺寸为 24KB devDependencies 和 dependencies 区别 网上统一的观念是 devDependencies 用于本地环境开发时候。 dependencies 用户发布环境 其实看名字我也知道是这个意思，我觉得没解释情况。 devDependencies 是只会在开发环境下依赖的模块，生产环境不会被打入包内。通过 NODE_ENV=developement 或 NODE_ENV=production 指定开发还是生产环境。 而 dependencies 依赖的包不仅开发环境能使用，生产环境也能使用。其实这句话是重点，按照这个观念很容易决定安装模块时是使用–save 还是–save-dev。 关于 cookie 携带问题 cookie 携带：这个问题与你发起 ajax 请求的方式有关 fetch 在默认情况下, 不管是同域还是跨域 ajax 请求都不会带上 cookie, 只有当设置了 credentials 时才会带上该 ajax 请求所在域的 cookie, 服务端需要设置响应头 Access-Control-Allow-Credentials: true, 否则浏览器会因为安全限制而报错, 拿不到响应 axios 和 jQuery 在同域 ajax 请求时会带上 cookie, 跨域请求不会, 跨域请求需要设置 withCredentials 和服务端响应头 默认情况下，一般浏览器的 CORS 跨域请求都是不会发送 cookie 等认证信息到服务端的，除非指定了 xhr.withCredentials = true，但是只有客户端单方面的设置了这个值还不行，服务端也需要同意才可以，所以服务端也需要设置好返回头 Access-Control-Allow-Credentials: true；还有一点要注意的，返回头 Access-Control-Allow-Origin 的值不能为星号，必须是指定的域，否则 cookie 等认证信息也是发送不了。 process.argv属性返回一个数组，这个数组包含了启动 Node.js 进程时的命令行参数。第一个元素为 process.execPath。如果需要获取 argv[0]的值请参见 node 文档的 process.argv0。第二个元素为当前执行的 JavaScript 文件路径。剩余的元素为其他命令行参数。 CORS 的相关设置 Access-Control-Allow-Origin: * // 跨域时，如果客户端ajax设置了withCredentials: true，就不可以为通配符，否则浏览器还是会跨域拦截 Access-Control-Allow-Credentials: true // 表示客户端是否可以发送Cookie Access-Control-Expose-Headers: FooBar Content-Type: text/html; charset=utf-8 // ajax set 跨域携带证书 xhrFields: &#123; withCredentials: true &#125; 判断是否为对象 function isObject(x) &#123; return Object.prototype.toString.call(x) === \"[object Object]\" &#125; (1,eval)(“str”) 等价于 (eval)(‘str’) =&gt; eval(‘str’) (1,2,3,4) === 4 // true 易混淆的判断真假 0 判断为 false “0” 判断为 true “” 判断为 false “null” 判断为 true Promise 相关写法 var p1 = Promise.resolve(value) // 等价于 var p1 = new Promise(resolve =&gt; resolve(value)) var p2 = Promise.reject(\"err\") // 等价于 var p2 = new Promise((resolve, reject) =&gt; reject(\"err\")) pm2 常用命令 $ pm2 logs 显示所有进程日志 $ pm2 stop all 停止所有进程 $ pm2 restart all 重启所有进程 $ pm2 reload all 0秒停机重载进程 (用于 NETWORKED 进程) $ pm2 stop 0 停止指定的进程 $ pm2 restart 0 重启指定的进程 $ pm2 startup 产生 init 脚本 保持进程活着 $ pm2 web 运行健壮的 computer API endpoint (http://localhost:9615) $ pm2 delete 0 杀死指定的进程 $ pm2 delete all 杀死全部进程 运行进程的不同方式： $ pm2 start app.js -i max 根据有效CPU数目启动最大进程数目 $ pm2 start app.js -i 3 启动3个进程 $ pm2 start app.js -x 用fork模式启动 app.js 而不是使用 cluster $ pm2 start app.js -x -- -a 23 用fork模式启动 app.js 并且传递参数 (-a 23) $ pm2 start app.js --name serverone 启动一个进程并把它命名为 serverone $ pm2 stop serverone 停止 serverone 进程 $ pm2 start app.json 启动进程, 在 app.json里设置选项 $ pm2 start app.js -i max -- -a 23 在--之后给 app.js 传递参数 $ pm2 start app.js -i max -e err.log -o out.log 启动 并 生成一个配置文件 pm2 启动文件 apps:json 结构，apps 是一个数组，每一个数组成员就是对应一个 pm2 中运行的应用 name:应用程序名称 cwd:应用程序所在的目录 script:应用程序的脚本路径 log_date_format: error_file:自定义应用程序的错误日志文件 out_file:自定义应用程序日志文件 pid_file:自定义应用程序的 pid 文件 instances: min_uptime:最小运行时间，这里设置的是 60s 即如果应用程序在 60s 内退出，pm2 会认为程- 序异常退出，此时触发重启 max_restarts 设置数量 max_restarts:设置应用程序异常退出重启的次数，默认 15 次（从 0 开始计数） cron_restart:定时启动，解决重启能解决的问题 watch:是否启用监控模式，默认是 false。如果设置成 true，当应用程序变动时，pm2 会自- 动重载。这里也可以设置你要监控的文件。 merge_logs: exec_interpreter:应用程序的脚本类型，这里使用的 shell，默认是 nodejs exec_mode:应用程序启动模式，这里设置的是 cluster_mode（集群），默认是 fork autorestart:启用/禁用应用程序崩溃或退出时自动重启 vizion:启用/禁用 vizion 特性(版本控制) onpagehide,onunload,onpageshow,onload // onpageshow 事件类似于 onload 事件，onload 事件在页面第一次加载时触发， onpageshow // 事件在每次加载页面时触发，即 onload 事件在页面从浏览器缓存中读取时不触发 event.persisted 判断页面是否从缓存中加载 JS 模块化写法 let module = (function() &#123; let count = 1 return &#123; add: function(count) &#123; return this.count + count &#125; &#125; &#125;)() 得到一个键盘 // 用字符串返回一个键盘图形 ;(_ =&gt; [...\"`1234567890-=~~QWERTYUIOP[]\\\\~ASDFGHJKL;'~~ZXCVBNM,./~\"].map( x =&gt; ((o += `/$&#123;(b = \"_\".repeat( (w = x &lt; y ? 2 : \" 667699\"[ ((x = [\"BS\", \"TAB\", \"CAPS\", \"ENTER\"][p++] || \"SHIFT\"), p) ]) ))&#125;\\\\|`), (m += y + (x + \" \").slice(0, w) + y + y), (n += y + b + y + y), (l += \" __\" + b))[73] &amp;&amp; (k.push(l, m, n, o), (l = \"\"), (m = n = o = y)), (m = n = o = y = \"|\"), (p = l = k = []) ) &amp;&amp; k.join` `)() 中文输入下 input 的 compositionstart 与 compositionend，实现仅在选词后触发 input 事件 var typing = false $(\"#ipt\").on(\"compositionstart\", function() &#123; typing = true &#125;) $(\"#ipt\").on(\"compositionend\", function() &#123; typing = false &#125;) //oninput在oncompositionend之前执行，需加定时器 $(\"#ipt\").on(\"input\", function() &#123; setTimeout(function() &#123; if (!typing) &#123; //To do something... &#125; &#125;, 0) &#125;) //或用keyup代替input $(\"#ipt\").on(\"keyup\", function() &#123; if (!typing) &#123; //To do something... &#125; &#125;)","permalink":"https://blog.utone.xyz/2019061421187/","photos":[]},{"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://blog.utone.xyz/tags/JavaScript/"}],"title":"总结笔记20190415","date":"2019/04/15","text":"Async/Await 从 Node 版本 v7.6.0 开始支持 setTimeout 的定时器值推荐最小使用 16.7ms 的原因（16.7 = 1000 / 60, 即每秒 60 帧） 超出部分展示省略号 // css控制行数展示，省略号 .ellipsis &#123; word-wrap: break-word; // 允许长单词换行到下一行 overflow: hidden; text-overflow: ellipsis; // 显示省略符号来代表被修剪的文本 string 可以给定string display: -webkit-box; -webkit-line-clamp: 3; // Safari、Opera 以及 Chrome -webkit-box-orient: vertical; &#125; .ellipsis &#123; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; &#125; vscode 中 vue 无法格式化 &#123; \"vetur.format.defaultFormatterOptions\": &#123; \"js-beautify-html\": &#123; \"wrap_attributes\": \"force-aligned\" &#125;, \"prettyhtml\": &#123; \"printWidth\": 100, \"singleQuote\": false, \"wrapAttributes\": false, \"sortAttributes\": true &#125;, // --- 解决问题 --- \"prettier\": &#123; \"semi\": false, \"singleQuote\": true &#125; // --- 解决问题 --- &#125; &#125; offsetTop，获取的距离最近的 offsetParent 的顶部高度，offsetParent 是距离该元素设置过 postion 的父元素（设置过定位的父元素）、否则 offsetParent 就是 body 元素 getBoundingClientRect() // 使用该方法，获取距离视窗顶部的高度 window.scrollTo(x, y) x,y 为小数时，实际滚动时，是向下取整 p 标签中不能包含 display:block 的元素，否则浏览器解析错误 _.isEmpty(123) === true 纯数字判断为真，一般校验对象 想要 div 触发 focus 和 blur，需要添加 tabIndex 属性 判断空数组，空对象方法 Object.keys().length !== 0 判断是否为对象 function isObject(x) &#123; return Object.prototype.toString.call(x) === '[object Object]' &#125; (1,eval)(“str”) 等价于 (eval)(‘str’) =&gt; eval(‘str’) (1,2,3,4) === 4 // true 易混淆的判断真假 0 判断为 false “0” 判断为 true “” 判断为 false “null” 判断为 true Promise 相关写法 var p1 = Promise.resolve(value) // 等价于 var p1 = new Promise(resolve =&gt; resolve(value)) var p2 = Promise.reject('err') // 等价于 var p2 = new Promise((resolve, reject) =&gt; reject('err')) pm2 常用命令 $ pm2 logs 显示所有进程日志 $ pm2 stop all 停止所有进程 $ pm2 restart all 重启所有进程 $ pm2 reload all 0秒停机重载进程 (用于 NETWORKED 进程) $ pm2 stop 0 停止指定的进程 $ pm2 restart 0 重启指定的进程 $ pm2 startup 产生 init 脚本 保持进程活着 $ pm2 web 运行健壮的 computer API endpoint (http://localhost:9615) $ pm2 delete 0 杀死指定的进程 $ pm2 delete all 杀死全部进程 运行进程的不同方式： $ pm2 start app.js -i max 根据有效CPU数目启动最大进程数目 $ pm2 start app.js -i 3 启动3个进程 $ pm2 start app.js -x 用fork模式启动 app.js 而不是使用 cluster $ pm2 start app.js -x -- -a 23 用fork模式启动 app.js 并且传递参数 (-a 23) $ pm2 start app.js --name serverone 启动一个进程并把它命名为 serverone $ pm2 stop serverone 停止 serverone 进程 $ pm2 start app.json 启动进程, 在 app.json里设置选项 $ pm2 start app.js -i max -- -a 23 在--之后给 app.js 传递参数 $ pm2 start app.js -i max -e err.log -o out.log 启动 并 生成一个配置文件 pm2 启动文件 apps:json 结构，apps 是一个数组，每一个数组成员就是对应一个 pm2 中运行的应用 name:应用程序名称 cwd:应用程序所在的目录 script:应用程序的脚本路径 log_date_format: error_file:自定义应用程序的错误日志文件 out_file:自定义应用程序日志文件 pid_file:自定义应用程序的 pid 文件 instances: min_uptime:最小运行时间，这里设置的是 60s 即如果应用程序在 60s 内退出，pm2 会认为程- 序异常退出，此时触发重启 max_restarts 设置数量 max_restarts:设置应用程序异常退出重启的次数，默认 15 次（从 0 开始计数） cron_restart:定时启动，解决重启能解决的问题 watch:是否启用监控模式，默认是 false。如果设置成 true，当应用程序变动时，pm2 会自- 动重载。这里也可以设置你要监控的文件。 merge_logs: exec_interpreter:应用程序的脚本类型，这里使用的 shell，默认是 nodejs exec_mode:应用程序启动模式，这里设置的是 cluster_mode（集群），默认是 fork autorestart:启用/禁用应用程序崩溃或退出时自动重启 vizion:启用/禁用 vizion 特性(版本控制) onpagehide,onunload,onpageshow,onload // onpageshow 事件类似于 onload 事件，onload 事件在页面第一次加载时触发， onpageshow // 事件在每次加载页面时触发，即 onload 事件在页面从浏览器缓存中读取时不触发 event.persisted 判断页面是否从缓存中加载 JS 模块化写法 let module = (function() &#123; let count = 1 return &#123; add: function(count) &#123; return this.count + count &#125; &#125; &#125;)() 得到一个键盘 // 用字符串返回一个键盘图形 ;(_ =&gt; [...\"`1234567890-=~~QWERTYUIOP[]\\\\~ASDFGHJKL;'~~ZXCVBNM,./~\"].map( x =&gt; ((o += `/$&#123;(b = '_'.repeat( (w = x &lt; y ? 2 : ' 667699'[ ((x = ['BS', 'TAB', 'CAPS', 'ENTER'][p++] || 'SHIFT'), p) ]) ))&#125;\\\\|`), (m += y + (x + ' ').slice(0, w) + y + y), (n += y + b + y + y), (l += ' __' + b))[73] &amp;&amp; (k.push(l, m, n, o), (l = ''), (m = n = o = y)), (m = n = o = y = '|'), (p = l = k = []) ) &amp;&amp; k.join` `)() 中文输入下 input 的 compositionstart 与 compositionend，实现仅在选词后触发 input 事件 var typing = false $('#ipt').on('compositionstart', function() &#123; typing = true &#125;) $('#ipt').on('compositionend', function() &#123; typing = false &#125;) //oninput在oncompositionend之前执行，需加定时器 $('#ipt').on('input', function() &#123; setTimeout(function() &#123; if (!typing) &#123; //To do something... &#125; &#125;, 0) &#125;) //或用keyup代替input $('#ipt').on('keyup', function() &#123; if (!typing) &#123; //To do something... &#125; &#125;)","permalink":"https://blog.utone.xyz/2019041521155/","photos":[]},{"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://blog.utone.xyz/tags/JavaScript/"},{"name":"Eslint","slug":"Eslint","permalink":"https://blog.utone.xyz/tags/Eslint/"}],"title":"Eslint 配置参数说明","date":"2019/04/15","text":"Eslint 配置参数说明 0 或’off’：关闭规则。 1 或’warn’：打开规则，并且作为一个警告（并不会导致检查不通过）。 2 或’error’：打开规则，并且作为一个错误 (退出码为 1，检查不通过)。 ESLint 常用配置 Possible Errors 可能的错误或逻辑错误 no-cond-assign 禁止条件表达式中出现模棱两可的赋值操作符 no-console 禁用 console no-constant-condition 禁止在条件中使用常量表达式 no-debugger 禁用 debugger no-dupe-args 禁止 function 定义中出现重名参数 no-dupe-keys 禁止对象字面量中出现重复的 key no-duplicate-case 禁止出现重复的 case 标签 no-empty 禁止出现空语句块 no-ex-assign 禁止对 catch 子句的参数重新赋值 no-extra-boolean-cast 禁止不必要的布尔转换 no-extra-parens 禁止不必要的括号 no-extra-semi 禁止不必要的分号 no-func-assign 禁止对 function 声明重新赋值 no-inner-declarations 禁止在嵌套的块中出现变量声明或 function 声明 no-irregular-whitespace 禁止在字符串和注释之外不规则的空白 no-obj-calls 禁止把全局对象作为函数调用 no-sparse-arrays 禁用稀疏数组 no-prototype-builtins 禁止直接使用 Object.prototypes 的内置属性 no-unexpected-multiline 禁止出现令人困惑的多行表达式 no-unreachable 禁止在 return、throw、continue 和 break 语句之后出现不可达代码 use-isnan 要求使用 isNaN() 检查 NaN valid-typeof 强制 typeof 表达式与有效的字符串进行比较 Best Practices 最佳实践 array-callback-return 强制数组方法的回调函数中有 return 语句 block-scoped-var 强制把变量的使用限制在其定义的作用域范围内 complexity 指定程序中允许的最大环路复杂度 consistent-return 要求 return 语句要么总是指定返回的值，要么不指定 curly 强制所有控制语句使用一致的括号风格 default-case 要求 switch 语句中有 default 分支 dot-location 强制在点号之前和之后一致的换行 dot-notation 强制在任何允许的时候使用点号 eqeqeq 要求使用 === 和 !== guard-for-in 要求 for-in 循环中有一个 if 语句 no-alert 禁用 alert、confirm 和 prompt no-case-declarations 不允许在 case 子句中使用词法声明 no-else-return 禁止 if 语句中有 return 之后有 else no-empty-function 禁止出现空函数 no-eq-null 禁止在没有类型检查操作符的情况下与 null 进行比较 no-eval 禁用 eval() no-extra-bind 禁止不必要的 .bind() 调用 no-fallthrough 禁止 case 语句落空 no-floating-decimal 禁止数字字面量中使用前导和末尾小数点 no-implicit-coercion 禁止使用短符号进行类型转换 no-implicit-globals 禁止在全局范围内使用 var 和命名的 function 声明 no-invalid-this: 禁止 this 关键字出现在类和类对象之外 no-lone-blocks 禁用不必要的嵌套块 no-loop-func 禁止在循环中出现 function 声明和表达式 no-magic-numbers 禁用魔术数字 no-multi-spaces 禁止使用多个空格 no-multi-str 禁止使用多行字符串 no-new 禁止在非赋值或条件语句中使用 new 操作符 no-new-func 禁止对 Function 对象使用 new 操作符 no-new-wrappers 禁止对 String，Number 和 Boolean 使用 new 操作符 no-param-reassign 不允许对 function 的参数进行重新赋值 no-redeclare 禁止使用 var 多次声明同一变量 no-return-assign 禁止在 return 语句中使用赋值语句 no-script-url 禁止使用 javascript: url no-self-assign 禁止自我赋值 no-self-compare 禁止自身比较 no-sequences 禁用逗号操作符 no-unmodified-loop-condition 禁用一成不变的循环条件 no-unused-expressions 禁止出现未使用过的表达式 no-useless-call 禁止不必要的 .call() 和 .apply() no-useless-concat 禁止不必要的字符串字面量或模板字面量的连接 vars-on-top 要求所有的 var 声明出现在它们所在的作用域顶部 Strict Mode 使用严格模式和严格模式指 strict 要求或禁止使用严格模式指令 Variables 变量声明 init-declarations 要求或禁止 var 声明中的初始化 no-catch-shadow 不允许 catch 子句的参数与外层作用域中的变量同名 no-restricted-globals 禁用特定的全局变量 no-shadow 禁止 var 声明 与外层作用域的变量同名 no-undef 禁用未声明的变量，除非它们在 /global / 注释中被提到 no-undef-init 禁止将变量初始化为 undefined no-unused-vars 禁止出现未使用过的变量 no-use-before-define 不允许在变量定义之前使用它们 Nodejs and CommonJS Node.js,CommonJS global-require 要求 require() 出现在顶层模块作用域中 handle-callback-err 要求回调函数中有容错处理 no-mixed-requires 禁止混合常规 var 声明和 require 调用 no-new-require 禁止调用 require 时使用 new 操作符 no-path-concat 禁止对 dirname 和 filename 进行字符串连接 no-restricted-modules 禁用指定的通过 require 加载的模块 Stylistic Issues 风格指南 array-bracket-spacing 强制数组方括号中使用一致的空格 block-spacing 强制在单行代码块中使用一致的空格 brace-style 强制在代码块中使用一致的大括号风格 camelcase 强制使用骆驼拼写法命名约定 comma-spacing 强制在逗号前后使用一致的空格 comma-style 强制使用一致的逗号风格 computed-property-spacing 强制在计算的属性的方括号中使用一致的空格 eol-last 强制文件末尾至少保留一行空行 func-names 强制使用命名的 function 表达式 func-style 强制一致地使用函数声明或函数表达式 indent 强制使用一致的缩进 jsx-quotes 强制在 JSX 属性中一致地使用双引号或单引号 key-spacing 强制在对象字面量的属性中键和值之间使用一致的间距 keyword-spacing 强制在关键字前后使用一致的空格 linebreak-style 强制使用一致的换行风格 lines-around-comment 要求在注释周围有空行 max-depth 强制可嵌套的块的最大深度 max-len 强制一行的最大长度 max-lines 强制最大行数 max-nested-callbacks 强制回调函数最大嵌套深度 max-params 强制 function 定义中最多允许的参数数量 max-statements 强制 function 块最多允许的的语句数量 max-statements-per-line 强制每一行中所允许的最大语句数量 new-cap 要求构造函数首字母大写 new-parens 要求调用无参构造函数时有圆括号 newline-after-var 要求或禁止 var 声明语句后有一行空行 newline-before-return 要求 return 语句之前有一空行 newline-per-chained-call 要求方法链中每个调用都有一个换行符 no-array-constructor 禁止使用 Array 构造函数 no-continue 禁用 continue 语句 no-inline-comments 禁止在代码行后使用内联注释 no-lonely-if 禁止 if 作为唯一的语句出现在 else 语句中 no-mixed-spaces-and-tabs 不允许空格和 tab 混合缩进 no-multiple-empty-lines 不允许多个空行 no-negated-condition 不允许否定的表达式 no-plusplus 禁止使用一元操作符 ++ 和 – no-spaced-func 禁止 function 标识符和括号之间出现空格 no-ternary 不允许使用三元操作符 no-trailing-spaces 禁用行尾空格 no-whitespace-before-property 禁止属性前有空白 object-curly-newline 强制花括号内换行符的一致性 object-curly-spacing 强制在花括号中使用一致的空格 object-property-newline 强制将对象的属性放在不同的行上 one-var 强制函数中的变量要么一起声明要么分开声明 one-var-declaration-per-line 要求或禁止在 var 声明周围换行 operator-assignment 要求或禁止在可能的情况下要求使用简化的赋值操作符 operator-linebreak 强制操作符使用一致的换行符 quote-props 要求对象字面量属性名称用引号括起来 quotes 强制使用一致的反勾号、双引号或单引号 require-jsdoc 要求使用 JSDoc 注释 semi 要求或禁止使用分号而不是 ASI semi-spacing 强制分号之前和之后使用一致的空格 sort-vars 要求同一个声明块中的变量按顺序排列 space-before-blocks 强制在块之前使用一致的空格 space-before-function-paren 强制在 function 的左括号之前使用一致的空格 space-in-parens 强制在圆括号内使用一致的空格 space-infix-ops 要求操作符周围有空格 space-unary-ops 强制在一元操作符前后使用一致的空格 spaced-comment 强制在注释中 // 或 /* 使用一致的空格","permalink":"https://blog.utone.xyz/2019041516860/","photos":[]},{"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://blog.utone.xyz/tags/JavaScript/"}],"title":"H5与Native交互","date":"2019/04/15","text":"介绍三种 APP 的开发模式 Native WebAPP HybridAPP Native优点 原生应用。性能最好，交互体验有优势 可以调用移动硬件设备的底层功能（摄像头、日历和地理位置等） 缺点 更新体验较差、需要用户手动更新。 苹果商店发布流程繁琐 使用不同的开发语言，所以开发、维护成本大 WebAPP优点 开发成本低，效率快 跨平台、升级维护简单，不受应用商店限制 不需要用户下载使用，有浏览器即可访问 缺点 依赖网络，访问速度受限于终端网速。每次访问，消耗流量 性能差，用户体验较差（因为需要去远端下载资源） 无法调用移动硬件设备的底层功能（摄像头、日历和地理位置等） HybridAPP优点 开发成本较低，效率较快,性能介于 Native 与 WebAPP 之间，可与 Nactive 媲美 跨平台、实现多端展示同一个交互层 可以调用移动硬件设备的底层功能（摄像头、日历和地理位置等） 缺点 用户需要在应用商店下载，发布流程繁琐 团队中需要有懂 Web、IOS 开发的技术人员，双方需要配合工作 Crocodile 框架中通信 执行 webapck 打包 Hybrid 包时，将 vendor/bridge.js 文件打包至 crocodile.seed.js 中，在前端应用启动时，优先于其他脚本代码加载。 当 Native 的 webview 加载完成后，调用 H5 的web_view_finished_load接口获取 Nacti 端的基本信息(版本、系统参数…) 初始化WebSettings webSettings = mWebView.getSettings(); //Android容器允许JS脚本 webSettings.setJavaScriptEnabled(true); //Android容器设置侨连对象 mWebView.addJavascriptInterface(getJSBridge(), \"JSBridge\"); //Android4.2版本以上，本地方法要加上注解@JavascriptInterface，否则会找不到方法。 private Object getJSBridge()&#123; Object insertObj = new Object()&#123; @JavascriptInterface public String foo()&#123; return \"foo\"; &#125; @JavascriptInterface public String foo2(final String param)&#123; return \"foo2:\" + param; &#125; &#125;; return insertObj; &#125; JS 调用//调用方法一 window.JSBridge.foo() //返回:'foo' //调用方法二 window.JSBridge.foo2('test') //返回:'foo2:test' 4.4 版本前// mWebView = new WebView(this); //即当前webview对象 mWebView.loadUrl(\"javascript: 方法名('参数,需要转为字符串')\"); //ui线程中运行 runOnUiThread(new Runnable() &#123; @Override public void run() &#123; mWebView.loadUrl(\"javascript: 方法名('参数,需要转为字符串')\"); Toast.makeText(Activity名.this, \"调用方法...\", Toast.LENGTH_SHORT).show(); &#125; &#125;); 4.4 版本后（包括）//异步执行JS代码,并获取返回值 mWebView.evaluateJavascript(\"javascript: 方法名('参数,需要转为字符串')\", new ValueCallback() &#123; @Override public void onReceiveValue(String value) &#123; //这里的value即为对应JS方法的返回值 &#125; &#125;);","permalink":"https://blog.utone.xyz/2019041543434/","photos":[]},{"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://blog.utone.xyz/tags/JavaScript/"}],"title":"函数防抖、函数节流","date":"2019/02/14","text":"函数消抖（debounce） 当调用函数 n 秒后，才会执行该动作，若在这 n 秒内又调用该函数则将取消前一次并重新计算执行时间 代码原理 设定一个全局变量保存定时器，事件触发时，判断定时器是否存在，存在时，消除定时器，不存在时，重新设定定时器，确保一段时间内，只存在一个定时器。 伪代码function _log() &#123; console.log('log') &#125; function _debounce(fn, delay) &#123; var timer = null return function() &#123; timer &amp;&amp; clearTimeout(timer) timer = setTimeout(function() &#123; fn() &#125;, delay) &#125; &#125; window.onresize = _debounce(_log, 1000) 函数节流（throttle） 函数预先设定一个执行周期，当调用动作的时刻大于等于执行周期则执行该动作，然后进入下一个新周期 代码原理 定义一个时间周期，当调用动作频率小于定义的时间周期，则进入下一周期，不会频繁触发 伪代码function _log() &#123; console.log('log') &#125; function _throttle(method, duration) &#123; var begin = new Date() return function() &#123; var _this = this, _args = arguments, current = new Date() if (current - begin &gt;= duration) &#123; method.apply(_this, _args) begin = current &#125; &#125; &#125; window.onresize = _throttle(_log, 1000)","permalink":"https://blog.utone.xyz/2019021449032/","photos":[]},{"tags":[{"name":"Linux","slug":"Linux","permalink":"https://blog.utone.xyz/tags/Linux/"},{"name":"Nginx","slug":"Nginx","permalink":"https://blog.utone.xyz/tags/Nginx/"}],"title":"Nginx开启gzip配置","date":"2019/02/01","text":"Nginx 开启 gzip 配置server &#123; listen 80; server_name www.utone.xyz; gzip on; gzip_min_length 1k; gzip_buffers 4 16k; gzip_comp_level 5; gzip_types text/plain application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png; gzip_vary on; gzip_disable \"MSIE [1-6].\"; location / &#123; root /data/blog/shixiaohu2206.github.io; #error_page 404/data/blog/shixiaohu2206.github.io/404.html; #try_files $uri /index.html; index index.html; &#125; &#125; 配置 gzip on设置允许压缩的页面最小字节数，页面字节数从 header 头中的 Content-Length 中进行获取默认值是 0，不管页面多大都压缩。建议设置成大于 1k 的字节数，小于 1k 可能会越压越大。 gzip_buffers 4 16k获取多少内存用于缓存压缩结果，‘4 16k’表示以 16k*4 为单位获得 gzip_comp_level 5gzip 压缩比（1~9），越小压缩效果越差，但是越大处理越慢，所以一般取中间值; gzip_types text/plain application/x-javascript text/css application/xml text/javascript application/x-httpd-php对特定的 MIME 类型生效,其中’text/html’被系统强制启用 gzip_http_version 1.1识别 http 协议的版本,早起浏览器可能不支持 gzip 自解压,用户会看到乱码 gzip_vary on启用应答头”Vary: Accept-Encoding” gzip_proxied offnginx 做为反向代理时启用,off(关闭所有代理结果的数据的压缩),expired(启用压缩,如果 header 头中包括”Expires”头信息),no-cache(启用压缩,header 头中包含”Cache-Control:no-cache”),no-store(启用压缩,header 头中包含”Cache-Control:no-store”),private(启用压缩,header 头中包含”Cache-Control:private”),no_last_modefied(启用压缩,header 头中不包含”Last-Modified”),no_etag(启用压缩,如果 header 头中不包含”Etag”头信息),auth(启用压缩,如果 header 头中包含”Authorization”头信息) gzip_disable msie6(IE5.5 和 IE6 SP1 使用 msie6 参数来禁止 gzip 压缩 )指定哪些不需要 gzip 压缩的浏览器(将和 User-Agents 进行匹配),依赖于 PCRE 库","permalink":"https://blog.utone.xyz/2019020134456/","photos":[]},{"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://blog.utone.xyz/tags/JavaScript/"}],"title":"滚动置顶元素","date":"2019/01/30","text":"首先设置父元素为相对定位.parent &#123; position: relative; top: 10rem; &#125; 设置一个 fixed 的 class.fixed &#123; position: fixed; top: 2rem; &#125; jqeury 伪代码$(document).ready(function() &#123; // 元素距离屏幕顶端的高度 var _offectTop = $('.introduce').offset().top // 滚动事件 $(document).scroll(function() &#123; // 滚动距离document的top高度 var _scrollTop = $(document).scrollTop() // 32 为距离顶部的流出的距离相当于2rem if (_scrollTop &gt;= _offectTop - 32) &#123; $('.introduce').addClass('fixed') &#125; else &#123; console.log(1) $('.introduce').removeClass('fixed') &#125; &#125;) &#125;) JS 原生代码实现/** * 目前将父元素设置margin-top，不设置相对定位，解决锚点bug * todo目前遇到BUG，点击锚点后，元素置顶了 **/ window.onload = function() &#123; /** * 原生offsetTop取值为相对于父元素， jquery的offset().top是取的距离屏幕顶部的距离 * 所以这里取父元素的offestTop **/ var _parentDom = document.getElementById('main-left') var _offectTop = _parentDom.offsetTop var _needTopDom = document.getElementById('introduce') window.onscroll = function() &#123; /** * 获取滚动距离document的高度 * * 声明了&lt;!DOCTYPE html&gt;，使用document.documentElement.scrollTop * 没有声明，使用document.body.scrollTop **/ var _scrollTop = document.body.scrollTop || document.documentElement.scrollTop // 32为距离顶部的流出的距离相当于2rem if (_scrollTop &gt; _offectTop - 32) &#123; _needTopDom.classList.add('fixed') &#125; else &#123; _needTopDom.classList.remove('fixed') &#125; &#125; &#125;","permalink":"https://blog.utone.xyz/2019013028409/","photos":[]},{"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://blog.utone.xyz/tags/JavaScript/"},{"name":"ES6","slug":"ES6","permalink":"https://blog.utone.xyz/tags/ES6/"}],"title":"总结笔记20190104","date":"2019/01/04","text":"lodash 函数 _.camelCase([string=’’])：转换字符串为 驼峰写法(小驼峰) _.isNil(value)：检查 value 是否是 null 或者 undefined。 _.size()：返回集合的长度或对象中可枚举属性的个数。 _.isPlainObject(): 检查是否是普通对象。 也就是说该对象由 Object 构造函数创建，或者 [[Prototype]] 为 null _.pick(object, *keys) 返回一个只有列入挑选 key 属性的对象 _.omit(object, [props]) 反向版的 pick，忽略[props]，返回之外的属性 _.identity(value) stooge === _.identity(stooge); // true 返回本身 _.rest(arguments, 0): ( 默认从 1 位开始),返回 0 位之后的数组 node 全局对象 process.cwd()获得当前执行 node 命令时候的文件夹目录名 process.execPath 属性，返回启动 Node.js 进程的可执行文件所在的绝对路径/usr/local/bin/node process.argv 属性返回一个数组,数组包含了启动 Node.js 进程时的命令行参数 $ node process-args.js one two=three four /** 0: /usr/local/bin/node 1: /Users/mjr/work/node/process-args.js 2: one 3: two=three 4: four **/ __dirname 获得当前执行文件所在目录的完整目录名 __filename 获得当前执行文件的带有完整绝对路径的文件名 Javascript 相关 toFixed() 方法可把 Number 四舍五入为指定小数位数的数字。 // https://www.jianshu.com/p/849b0ae36b36 不可用于高精度运算，金钱运算 var a = 1.335 console.log(a.toFixed(2)) // IE 1.34 //chorme 1.33 Javascript 按位取反运算符 (~) // Javascript 按位取反运算符 (~) ，对一个表达式执行位非（求非）运算。 // 就来看看~1的计算步骤： // 将1(这里叫：原码)转二进制 ＝ 00000001 按位取反 ＝ 11111110 发现符号位(即最高位)为1(表示负数)，将除符号位之外的其他数字取反 ＝ 10000001 末位加1取其补码 ＝ 10000010 转换回十进制 ＝ -2 var str = &apos;123456&apos; // ~-1 === 0 if(~str.indexOf(0))&#123; console.log(&apos;str包含0&apos;) &#125; else &#123; console.log(&apos;str不包含0&apos;) &#125; 面试题实现(a==1 &amp;&amp; a==2 &amp;&amp; a==3) === true 双等于号 const a = &#123; value : 0 &#125;; a.valueOf = function() &#123; return this.value += 1; &#125;; console.log(a==1 &amp;&amp; a==2 &amp;&amp; a==3); //true 面试题实现(a===1 &amp;&amp; a===2 &amp;&amp; a===3) === true 全等 // window.value var value = 0; // 重写get取值方式 Object.defineProperty(window, &apos;a&apos;, &#123; get: function() &#123; return this.value += 1; &#125; &#125;); console.log(a===1 &amp;&amp; a===2 &amp;&amp; a===3) // true 利用 es6 函数 reduce，并行执行 promise return bizs.reduce((pro, biz) =&gt; &#123; return pro.then(() =&gt; this.copySingleWithObserve(biz)) &#125;, Promise.resolve()) Object.create(null) 与 {} 区别 区别 Object.create(null)不会继承 Object 原型上的任何东西 如没有继承方法 toString(){}创建的新对象会继承所有 Object 的属性 因为使用 create 创建的没有任何属性 可以自己定义 hasOwnProperty,toString()方法等 为什么用 Object.create(null) 因为使用 create 创建的没有任何属性 可以自己定义 hasOwnProperty,toString()方法等 for in 循环的时候不会再遍历原型链上的属性 ,使用 create(null)就不会再对属性进行检查了,也可以使用 Object.keys[] 什么时候用 Object.create(null) 你需要一个非常干净且高度可定制的对象当做数据字典的时候,比如 serverAPI 里的一些变量 减少 hasOwnProperty 造成的性能损失 require 和 import require commonJS（适用于服务端，同步加载） 运行时加载 拷贝到本页面 全部引入 模块写法分 exports 和 module.exports。 AMD (适用于客户端，异步加载) AMD 是”Asynchronous Module Definition”的缩写，意思就是”异步模块定义”//require([module], callback); require(['math'], function (math) &#123; math.add(2, 3); &#125;); // 模块写法 dependencies依赖模块 define(id?, dependencies?, factory) CMD CMD 是”Common Module Definition”的缩写。类似于 requirejs，但是 seajs 是依赖就近，延迟执行，requirejs 是依赖前置，提前执行。 import 推荐使用 ES6 的 import 编译时加载 只引用定义 按需加载 NodeJS 查看 ES6 支持率// nodejs 8.0以上支持原生es6方法 $ node -v v10.13. npm install -g es-checker // 安装完毕，运行 es-checke // 查看当前版本es6原生支持率92% ========================================= Passes 39 feature Detections Your runtime supports 92% of ECMAScript 6 ========================================= package.json 中配置版本号 ‘~’: ‘~2.3.1’,则更新’2.3.x’中最新的小版本,不会去更新’2.4.x’ ‘^’: ‘^2.2.2’,则会去找’2.x.x’中最新的，不会去更新’3.x.x’ setTimeout// setTimeout的一道面试题 for (var i = 0; i &lt; 5; i++) &#123; setTimeout(function() &#123; console.log(i) &#125;, 1000) &#125; //5,5,5,5,5 为什么会输出 5,5,5,5,5，而不是 0,1,2,3,4，因为 setTimeout 在 for 循环中异步的执行，将输出打印的操作，队列在 for 循环执行完之后。 删除 js 数组中的某个元素var _arr = ['a', 'b', 'c', 'ALL'] var _str = _arr.join(',') var _index = _str.indexOf('ALL') // 获取\"ALL\"的位置 _arr.splice(_index, 1) // 去除该元素（会改变原数组） console.log(_arr) // [\"a\", \"b\", \"c\"]","permalink":"https://blog.utone.xyz/20190104883/","photos":[]},{"tags":[{"name":"javascript","slug":"javascript","permalink":"https://blog.utone.xyz/tags/javascript/"}],"title":"无重复字符的最长子串","date":"2018/10/17","text":"/* * 无重复字符的最长子串 * leetcode 算法题3 */ // 解法一 var map = &#123;&#125; var head = 0 var i = 0 var max = 0 for (i; i &lt; s.length; i++) &#123; if (map[s[i]] &gt;= head) &#123; head = map[s[i]] + 1 &#125; map[s[i]] = i max = max &gt; i - head + 1 ? max : i - head + 1 &#125; return max // 解法二 const map = &#123;&#125; let left = 0 let max = s.split('').reduce((max, v, i) =&gt; &#123; /* * map[v] 初始为underfined，表明s[i]还没出现过， * 一旦map[v]有值了，且大于left，就将left的值设为map[v]后一位 */ left = map[v] &gt;= left ? map[v] + 1 : left map[v] = i return Math.max(max, i - left + 1) &#125;, 0) console.log(max)","permalink":"https://blog.utone.xyz/2018101714283/","photos":[]},{"tags":[{"name":"Css","slug":"Css","permalink":"https://blog.utone.xyz/tags/Css/"},{"name":"Float","slug":"Float","permalink":"https://blog.utone.xyz/tags/Float/"}],"title":"css浮动后父元素高度坍塌","date":"2018/10/17","text":"/* * 父元素不写高度时，子元素写了浮动后，父元素会发生高度塌陷 * 所以要清除浮动 * 给父级添加overflow:hidden 清除浮动方法 * 万能清除法 after伪类 清浮动(现在主流方法，推荐使用) */ .float_div:after &#123; content: \".\"; clear: both; display: block; height: 0; overflow: hidden; visibility: hidden; &#125;","permalink":"https://blog.utone.xyz/2018101753956/","photos":[]},{"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://blog.utone.xyz/tags/JavaScript/"}],"title":"hasOwnProperty原型链方法","date":"2018/10/17","text":"/* * Object的hasOwnProperty()方法返回一个布尔值 * 判断对象是否包含特定的自身（非继承）属性。 * * 在看开源项目的过程中，经常会看到类似如下的源码 * for...in循环对象的所有枚举属性 * 然后再使用hasOwnProperty()方法来忽略继承属性。 */ var foo = &#123; hasOwnProperty: function() &#123; return false &#125;, bar: 'Here be dragons' &#125; foo.hasOwnProperty('bar') // 始终返回 false // 如果担心这种情况，可以直接使用原型链上真正的 hasOwnProperty 方法 // 使用另一个对象的`hasOwnProperty` 并且call ;(&#123;&#125;.hasOwnProperty.call(foo, 'bar')) // true // 也可以使用 Object 原型上的 hasOwnProperty 属性 Object.prototype.hasOwnProperty.call(foo, 'bar') // true","permalink":"https://blog.utone.xyz/2018101762112/","photos":[]},{"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://blog.utone.xyz/tags/JavaScript/"}],"title":"总结笔记20181017","date":"2018/10/17","text":"node 连接数据库时需要设置时区，不然查出来的时间格式不是东八区 no-referrer-when-downgrade 是 chrome 自动加的，表示从 https 降级到 http 时不发送 reffer Buffer.byteLength 获取字符串的字节长度 position: sticky 设置父元素 overflow:hidden 解决浮动后没有高度 // 聚合 array.reduce(function(total, currentValue, currentIndex, arr), initialValue) initialValue 初始值 total 必需。初始值, 或者计算结束后的返回值。 currentValue 必需。当前元素 currentIndex 可选。当前元素的索引 arr 可选。当前元素所属的数组对象。 []==![] true在相等运算符中，如果运算符两边的值有一个是布尔类型，则会把 true 转换成 1，false 则转换为 0相等运算符如果有一边是数字，而另一边是对象，则会把对象转换成数字。而空的数组对象转换成数字是 0![]会转化为 0, 而空的数组对象[]转换成数字是 0 所以为 true[]===![] 全等的话，为 false 函数声明、函数表达式 console.log(f1) // function f1() &#123;&#125; function f1() &#123;&#125; // 函数声明 console.log(f2) // undefined var f2 = function() &#123;&#125; // 函数表达式 node 最新版本 Node.js 10.11.0 2018-09-19 6.8.275.32 6.4.1 64 使用 Array.every 和 Array.some 来处理全部/部分满足条件 因为作用域链，外部不能访问内部的变量和方法，这时我们就需要通过闭包，返回内部的方法和变量给外部，从而就形成了一个闭包。 弹簧振动效果 css，类似于苹果手机打开图片 Transition: 0.6s cubic-bezir(.29,1.1,.29,1.1) github 徽章 https://img.shields.io/discourse/https/meta.discourse.org/topics.svg","permalink":"https://blog.utone.xyz/2018101728255/","photos":[]},{"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://blog.utone.xyz/tags/JavaScript/"}],"title":"JavaScript深拷贝","date":"2018/10/17","text":"slice 和 concat 这两个方法，仅适用于对不包含引用对象的一维数组的深拷贝，对于对象数组的操作，还是浅拷贝 JSON 对象的 parse 和 stringify （对象中不含有函数的话。JSON 解析反解析就行了,对于有函数属性的话，不起作用，会直接去除 function） $.extend( [deep], target, object1 [, objectN] ) jquery 的方法 extend b=$.extend(true,[],a); 递归复制 let d = JSON.parse(JSON.stringify(a)) //深复制包含子对象 let c = &#123; ...a &#125; //拷贝一层但不包含子对象 b = a //浅拷贝 // 基本类型 是深拷贝 var a = 1 var b = a a = 2 console.log(a, b) // 2, 1 ，a b指向不同的数据 // 引用类型指向同一份数据 var a = &#123; c: 1 &#125; var b = a a.c = 2 console.log(a.c, b.c) // 2, 2 全是 2，a b 指向同一份数据 //方法 1:通过递归 function deepCopy(o, c) &#123; var c = c || &#123;&#125; for (var i in o) &#123; if (typeof o[i] === 'object') &#123; if (o[i].constructor === Array) &#123; c[i] = [] &#125; else &#123; c[i] = &#123;&#125; &#125; deepCopy(c[i], o[i]) &#125; else &#123; c[i] = o[i] &#125; return c &#125; &#125; //方法 2:通过 json 解析 function不可复制 var result = JSON.parse(JSON.stringify(test))","permalink":"https://blog.utone.xyz/2018101729945/","photos":[]},{"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://blog.utone.xyz/tags/JavaScript/"},{"name":"Promise","slug":"Promise","permalink":"https://blog.utone.xyz/tags/Promise/"}],"title":"判断函数是否是Promise函数","date":"2018/09/29","text":"// 判断函数是否是Promise函数 function isPromise(obj) &#123; return ( !!obj &amp;&amp; (typeof obj === 'object' || typeof obj === 'function') &amp;&amp; typeof obj.then === 'function' ) &#125;","permalink":"https://blog.utone.xyz/2018092925453/","photos":[]},{"tags":[{"name":"PHP","slug":"PHP","permalink":"https://blog.utone.xyz/tags/PHP/"}],"title":"usort自定义排序","date":"2018/09/25","text":"工作上需要对 php 数组自定义排序，使用了 usort 函数，但若比较参数中，出现空字符串时，这样含有空字符串的元素就是拍在前面 $demo = [\"3\", \"2\" ,\"\", \"5\", \"\"]; // 使用自定义排序函数 usort($demo, \"myusort\"); /** * 不考虑元素为空字符串 * @param $a * @param $b * @return int */ function myusort($a, $b) &#123; // 差值 $diff = strtotime($a) - strtotime($b); if ($diff == 0) return 0; return $diff &gt; 0 ? 1 : -1; &#125; /* 结果为 array (size=5) 0 =&gt; string \"\" (length=0) 1 =&gt; string \"\" (length=0) 2 =&gt; string \"2\" (length=1) 3 =&gt; string \"3\" (length=1) 4 =&gt; string \"5\" (length=1) */ 现需求为元素为空字符串时，排在末尾 /** * 考虑元素为空字符串 * @param $a 为后一个元素 * @param $b 为前一个元素 * @return int 返回1，则位置不变化，返回-1则调换位置 * 返回0时、如果两个元素比较结果相同，则它们在排序后的数组中的顺序未经定义。 * 到 PHP 4.0.6 之前，用户自定义函数将保留这些元素的原有顺序。 * 但是由于在 4.1.0 中引进了新的排序算法，结果将不是这样了，因为对此没有一个有效的解决方案 */ function myusort($a, $b) &#123; // 单独做处理 if (empty($a)) &#123; return 1; &#125; if (empty($b)) &#123; return -1; &#125; // 差值 $diff = strtotime($a) - strtotime($b); if ($diff == 0) return 0; return $diff &gt; 0 ? 1 : -1; &#125; /* 结果为 array (size=5) 0 =&gt; string \"2\" (length=1) 1 =&gt; string \"3\" (length=1) 2 =&gt; string \"5\" (length=1) 3 =&gt; string \"\" (length=0) 4 =&gt; string \"\" (length=0) */","permalink":"https://blog.utone.xyz/201809254903/","photos":[]},{"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://blog.utone.xyz/tags/JavaScript/"}],"title":"parseInt兼容性","date":"2018/09/11","text":"/* * parseInt在不同的浏览器下有不同的默认行为处理 * 需要传为第二个参数10，采用10进制转化 */ parseInt('09') // IE8下，默认用八进制转化，结果为0 parseInt('09', 10) // IE8下，结果正常","permalink":"https://blog.utone.xyz/2018091122541/","photos":[]},{"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://blog.utone.xyz/tags/JavaScript/"},{"name":"React","slug":"React","permalink":"https://blog.utone.xyz/tags/React/"}],"title":"React生命周期","date":"2018/09/07","text":"Democlass Demo extends Component &#123; // 构造方法 // 只要组件存在constructor,就必要要写super,否则this指向会错误 constructor(props, context) &#123; spuer(props, context) &#125; // 组件将要加载 componentWillMount() &#123;&#125; // 组件加载完成，只在render后，调用一次 componentDidMount() &#123;&#125; // 接受新props时调用 componentWillReceiveProps(nextProps) &#123;&#125; // 接受下次props、state，判断是否更新组件，初始化时不调用 shouldComponentUpdate(nextProps, nextState) &#123;&#125; // 组件更改时 componentWillUpdate(nextProps, nextState) &#123;&#125; // 组件更改完成 componentDidUpdate(prevProps, prevState) &#123;&#125; // React 16 处理错误信息生命周期函数 componentDidCatch() &#123;&#125; // 组件从DOM中移除前触发 componentWillUnmount() &#123;&#125; // 渲染 render() &#123; return &lt;div /&gt; &#125; &#125; export default Demo constructor 构建函数 constructor 参数接受两个参数 props,context 可以获取到父组件传下来的的 props,context,如果你想在&gt;constructor 构造函数内部(注意是内部哦，在组件其他地方是可以直接接收的)使用 props 或 context,则需&gt;要传入，并传入 super 对象。 componentWillMount 组件将要挂载 组件刚经历 constructor,初始完数据 组件还未进入 render，组件还未渲染完成，dom 还未渲染 componentDidMount 组件渲染完成(只执行一次) 组件第一次渲染完成，此时 dom 节点已经生成，可以在这里调用 ajax 请求，返回数据 setState 后组件会重新渲染 componentWillReceiveProps (nextProps) 父组件 props 改变时调用、 使用 this.props 访问当前的 props，可以在此 setState 更新，重新渲染组件 shouldComponentUpdate(nextProps,nextState) return boolean， true 更新组件，false 为阻止更新 因为 react 父组件的重新渲染会导致其所有子组件的重新渲染，这个时候其实我们是不需要所有子组件都跟着重新渲染的，因此需要在子组件的该生命周期中做判断 componentWillUpdate (nextProps,nextState) shouldComponentUpdate 返回 true 以后，组件进入重新渲染的流程，进入 componentWillUpdate,这里同样可以拿到 nextProps 和 nextState render 函数 render 函数会插入 jsx 生成的 dom 结构，react 会生成一份虚拟 dom 树，在每一次组件更新时，在此 react 会通过其 diff 算法比较更新前后的新旧 DOM 树，比较以后，找到最小的有差异的 DOM 节点，并重新渲染 componentDidUpdate(prevProps,prevState) 组件更新完毕后，react 只会在第一次初始化成功会进入 componentDidmount,之后每次重新渲染后都会进入这个生命周期，这里可以拿到 prevProps 和 prevState，即更新前的 props 和 state。 componentWillUnmount () 在组件从 DOM 中移除的时候立刻被调用。","permalink":"https://blog.utone.xyz/2018090738908/","photos":[]},{"tags":[{"name":"React","slug":"React","permalink":"https://blog.utone.xyz/tags/React/"},{"name":"DvaJs","slug":"DvaJs","permalink":"https://blog.utone.xyz/tags/DvaJs/"},{"name":"Umi","slug":"Umi","permalink":"https://blog.utone.xyz/tags/Umi/"}],"title":"记博客搭建","date":"2018/08/22","text":"1、之前写过 WordPress 版的博客，使用别人造好的轮，但是始终感觉缺点什么 博客地址2、还用过 Hexo 搭建过博客，基本也是拿来主义 博客地址3、趁着工作中使用 React、Express 前后端分离的项目结构，决心搭建一个属于自己的博客系统4、奉行”先有再优“、后续会不断优化完善博客5、感谢大雄博客，灵感及页面样式从中获取很多 概述 前后端分离，前端使用 React 框架，分为前台、后台两个项目。后端使用 Express 框架 React1、React 版本为 &quot;react&quot;: &quot;^16.4.1&quot;2、使用 Ant Design 的一些基本组件，如弹出、表单组件，版本为&quot;antd&quot;: &quot;^3.8.0&quot;2、使用 Dvajs 和 Umi，重构了博客系统，也修改了样式布局3、使用 scss，css 的扩展，写样式更加简洁 Express1、使用 Express 的脚手架搭建、版本为 &quot;express&quot;: &quot;~4.16.0&quot;2、在加载路由前后，使用了一些中间件，后续将中间件整理出来3、使用 JWT，来验证请求 import &#123; Fragment, PureComponent &#125; from 'react' import &#123; BackTop, Icon, Row, Col &#125; from 'antd' import &#123; connect &#125; from 'dva' // import &#123; WiredCard &#125; from \"wired-elements\"; import withRouter from 'umi/withRouter' import &#123; TransitionGroup, CSSTransition &#125; from 'react-transition-group' import Header from './header/components/Header' import Footer from './footer/components/Footer' import Siderbar from './siderbar/components/siderbar' class Layout extends PureComponent &#123; shouldComponentUpdate(nextProps, nextState) &#123; if (nextProps.location.pathname === this.props.location.pathname) &#123; return false &#125; return true &#125; /** * xs &lt;576px * sm ≥576px * md ≥768px * lg ≥992px * xl ≥1200px * xxl ≥1600px */ render() &#123; const &#123; children, location &#125; = this.props // 前台布局 return ( &lt;Fragment&gt; &lt;div className=\"body\"&gt; &lt;Header /&gt; &lt;div className=\"main\"&gt; &lt;TransitionGroup&gt; &lt;CSSTransition key=&#123;location.key&#125; appear=&#123;true&#125; classNames=\"example\" timeout=&#123;&#123; enter: 300, exit: 100 &#125;&#125; &gt; &#123;children&#125; &lt;/CSSTransition&gt; &lt;/TransitionGroup&gt; &lt;/div&gt; &lt;/div&gt; &lt;Footer /&gt; &lt;/Fragment&gt; ) &#125; &#125; function mapStateToProps(state) &#123; return &#123;&#125; &#125; export default withRouter(connect(mapStateToProps)(Layout))","permalink":"https://blog.utone.xyz/2018082231017/","photos":[]},{"tags":[{"name":"Git","slug":"Git","permalink":"https://blog.utone.xyz/tags/Git/"}],"title":"git新建远程版本库","date":"2018/08/15","text":"前提为已安装好 git// 新建一个文件夹，文件名为项目名 mkdir hexo.git // 进入文件夹，初始化 cd hexo.git git init --bare // 生成好初始git文件后，更改文件夹的所属组，所属用户 chown -R git:git hexo.git","permalink":"https://blog.utone.xyz/2018081557915/","photos":[]},{"tags":[{"name":"VsCode","slug":"VsCode","permalink":"https://blog.utone.xyz/tags/VsCode/"}],"title":"VSCode常用插件","date":"2018/08/15","text":"Annotator查看 git 提交记录 Code Outline展示代码结构树 Git Blame在状态栏显示当前行的 Git 信息 GitLens显示文件最近的 commit 和作者，显示当前行 commit 信息 Git History(git log)查看 git log HTML CSS Supportcss 提示（支持 vue） Guides高亮缩进基准线 Prettify JSON格式化 JSON Prettier - Code formatter代码格式化 SCSS IntelliSensescss 智能提示 TSLintTSLint TypeScript ImporterTypeScript Importer vscode-icons图标","permalink":"https://blog.utone.xyz/2018081518925/","photos":[]},{"tags":[{"name":"PHP","slug":"PHP","permalink":"https://blog.utone.xyz/tags/PHP/"}],"title":"array_diff 数组差集","date":"2018/08/15","text":"定义：比较两个数组的键值，并返回差集，函数返回两个数组的差集数组。该数组包括了所有在被比较的数组中，但是不在任何其他参数数组中的键值。在返回的数组中，键名保持不变。 用法：array_diff(array1,array2,array3…); 可传多个数组，后续数组，与第一个数组对比，只能对比一维数组、对比二维数组时，抛出一个异常（Notice） 返回数组：返回差集数组，该数组包括了所有在被比较的数组（array1）中，但是不在任何其他参数数组（array2 或 array3 等等）中的键值。","permalink":"https://blog.utone.xyz/2018081534942/","photos":[]},{"tags":[{"name":"代理","slug":"代理","permalink":"https://blog.utone.xyz/tags/代理/"}],"title":"正向代理、反向代理","date":"2018/08/15","text":"github 博客地址：https://shixiaohu2206.github.io/ 正向代理 一般情况下，若没有特别说明的代理技术，通常指的是正向代理 正向代理(forward)是一个位于客户端【用户 A】和原始服务器(origin server)【服务器 B】之间的服务器【代理服务器 Z】，为了从原始服务器取得内容，用户 A 向代理服务器 Z 发送一个请求并指定目标(服务器 B)，然后代理服务器 Z 向服务器 B 转交请求并将获得的内容返回给客户端。客户端必须要进行一些特别的设置才能使用正向代理。（抄的） 自己的理解：用户想要访问原始服务器的内容，但是不能直接获取到，因为各种墙的缘故，但是中间的代理服务器可以访问的到，所以，用户就携带自己想要访问的地址（A 网址），先去访问代理服务器，代理服务器接受（A 网址），这时代理服务器再去访问（A 网址），获得到内容，返回给代理服务器，代理服务器再返回给用户。完成正向代理的一个流程。（翻墙就是正向代理） 反向代理 网上都在说什么正向代理与反向代理正好相反，这个相反在我看来只是相对的某一个点 反向代理的用户客户端，不需要做任何设置，需要设置的是反向代理服务器。 对于客户端而言它就像是原始服务器，并且客户端不需要进行任何特别的设置。客户端向反向代理的命名空间(name-space)中的内容发送普通请求，接着反向代理将判断向何处(原始服务器)转交请求，并将获得的内容返回给客户端，就像这些内容原本就是它自己的一样。 自己的理解：用户访问（A 网址），A 网址的代理服务器接受到用户的请求，但是真实的资源不在该代理服务器上，该代理服务器携带用户请求去访问原始的服务器，获得到内容，返回给代理服务器，代理服务器再返回给用户。完成反向代理的一个流程。用户不知道（A 网址）其实不是原始服务器，资源不在（A 网址）上 负载均衡 负载均衡是在反向代理的基础上实现的。当反向代理服务器不止一个的时候，我们甚至可以把它们做成集群，当更多的用户访问资源服务器 B 的时候，让不同的代理服务器 Z（x）去应答不同的用户，然后发送不同用户需要的资源。 当然反向代理服务器像正向代理服务器一样拥有 CACHE 的作用，它可以缓存原始资源服务器 B 的资源，而不是每次都要向原始资源服务器 B 请求数据，特别是一些静态的数据，比如图片和文件，如果这些反向代理服务器能够做到和用户 X 来自同一个网络，那么用户 X 访问反向代理服务器 X，就会得到很高质量的速度。这正是 CDN 技术的核心。 借用阿笠的一张图 Nginx 反向代理配置#反向代理,需要配置在server外面 upstream github.xiaohuaiqing.com &#123; server 119.29.9.63:4000; keepalive 2000; &#125; server &#123; listen 80; #listen [::]:80; server_name github.xiaohuaiqing.com; index index.html index.htm index.php default.html default.htm default.php; include other.conf; #error_page 404 /404.html; include enable-php.conf; #反向代理 location / &#123; proxy_pass http://github.xiaohuaiqing.com; proxy_set_header Host $host:$server_port; &#125; #单独加个css、js配置 location ~ .*.(js|css)$ &#123; proxy_pass http://github.xiaohuaiqing.com; proxy_set_header Host $host:$server_port; &#125; location ~ .*.(gif|jpg|jpeg|png|bmp|swf)$ &#123; expires 30d; &#125; location ~ .*.(js|css)?$ &#123; expires 12h; &#125; location ~ /. &#123; deny all; &#125; access_log /home/wwwlogs/github.xiaohuaiqing.com.log; &#125;","permalink":"https://blog.utone.xyz/2018081556401/","photos":[]},{"tags":[{"name":"PHP","slug":"PHP","permalink":"https://blog.utone.xyz/tags/PHP/"}],"title":"获取首字符拼音首字母","date":"2018/07/20","text":"/** * 获取首字符拼音首字母 * * 判断是否为汉字 !preg_match(\"/^[x&#123;4e00&#125;-x&#123;9fa5&#125;]+$/u\", $s0) * 已知 “泸”，无法识别 */ function getFirstPing($str) &#123; $s0 = mb_substr($str, 0, 1, \"utf-8\"); $fchar = ord($s0&#123;0&#125;); if ($fchar &gt;= ord(\"A\") and $fchar &lt;= ord(\"z\")) return strtoupper($s0&#123;0&#125;); $s1 = iconv(\"UTF-8\", \"gb2312\", $s0); $s2 = iconv(\"gb2312\", \"UTF-8\", $s1); if ($s2 == $s0) &#123; $s = $s1; &#125; else &#123; $s = $s0; &#125; $asc = ord($s&#123;0&#125;) * 256 + ord($s&#123;1&#125;) - 65536; if ($asc &gt;= -20319 &amp;&amp; $asc &lt;= -20284) return \"A\"; if ($asc &gt;= -20283 &amp;&amp; $asc &lt;= -19776) return \"B\"; if ($asc &gt;= -19775 &amp;&amp; $asc &lt;= -19219) return \"C\"; if ($asc &gt;= -19218 &amp;&amp; $asc &lt;= -18711) return \"D\"; if ($asc &gt;= -18710 &amp;&amp; $asc &lt;= -18527) return \"E\"; if ($asc &gt;= -18526 &amp;&amp; $asc &lt;= -18240) return \"F\"; if ($asc &gt;= -18239 &amp;&amp; $asc &lt;= -17923) return \"G\"; if ($asc &gt;= -17922 &amp;&amp; $asc &lt;= -17418) return \"H\"; if ($asc &gt;= -17922 &amp;&amp; $asc &lt;= -17418) return \"I\"; if ($asc &gt;= -17417 &amp;&amp; $asc &lt;= -16475) return \"J\"; if ($asc &gt;= -16474 &amp;&amp; $asc &lt;= -16213) return \"K\"; if ($asc &gt;= -16212 &amp;&amp; $asc &lt;= -15641) return \"L\"; if ($asc &gt;= -15640 &amp;&amp; $asc &lt;= -15166) return \"M\"; if ($asc &gt;= -15165 &amp;&amp; $asc &lt;= -14923) return \"N\"; if ($asc &gt;= -14922 &amp;&amp; $asc &lt;= -14915) return \"O\"; if ($asc &gt;= -14914 &amp;&amp; $asc &lt;= -14631) return \"P\"; if ($asc &gt;= -14630 &amp;&amp; $asc &lt;= -14150) return \"Q\"; if ($asc &gt;= -14149 &amp;&amp; $asc &lt;= -14091) return \"R\"; if ($asc &gt;= -14090 &amp;&amp; $asc &lt;= -13319) return \"S\"; if ($asc &gt;= -13318 &amp;&amp; $asc &lt;= -12839) return \"T\"; if ($asc &gt;= -12838 &amp;&amp; $asc &lt;= -12557) return \"W\"; if ($asc &gt;= -12556 &amp;&amp; $asc &lt;= -11848) return \"X\"; if ($asc &gt;= -11847 &amp;&amp; $asc &lt;= -11056) return \"Y\"; if ($asc &gt;= -11055 &amp;&amp; $asc &lt;= -10247) return \"Z\"; return $s0; &#125;","permalink":"https://blog.utone.xyz/201807205502/","photos":[]},{"tags":[{"name":"PHP","slug":"PHP","permalink":"https://blog.utone.xyz/tags/PHP/"},{"name":"MySql","slug":"MySql","permalink":"https://blog.utone.xyz/tags/MySql/"}],"title":"PHP连接MySql常用方法","date":"2017/11/30","text":"面向过程连接// 配置 $mysql_server=\"localhost\"; $mysql_username=\"数据库用户名\"; $mysql_password=\"数据库密码\"; $mysql_database=\"数据库名\"; // 建立数据库链接 $conn = mysql_connect($mysql_server,$mysql_username,$mysql_password) or die(\"数据库链接错误\"); // 选择某个数据库 mysql_select_db($mysql_database,$conn); mysql_query(\"set names \"utf8\"\"); // 执行MySQL语句 $result=mysql_query(\"SELECT id,name FROM 数据库表\"); // 提取数据 $row=mysql_fetch_row($result); 面向对象连接$db=new mysqli($dbhost,$username,$userpass,$dbdatabase); if(mysqli_connect_error())&#123; echo \"Could not connect to database.\"; exit; &#125; $result=$db-&gt;query(\"SELECT id,name FROM user\"); $row=$result-&gt;fetch_row(); PDO 连接方式$dsn=\"mysql:host=\".$dbhost.\";dbname=\".$dbdatabase.\";\" $dbh=new PDO($dsn,$username,$userpass); $stmt=$dbh-&gt;query(\"SELECT id,name FROM user\"); $row=$stmt-&gt;fetch();","permalink":"https://blog.utone.xyz/2017113016459/","photos":[]},{"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://blog.utone.xyz/tags/JavaScript/"}],"title":"slice、splice、split异同","date":"2017/11/01","text":"arguments 参数 生成JavaScript 在创建函数时，会自动生成一个 Arguments 对象实例 arguments，可以用数组下标的方式”[]”引用 arguments 的元素。arguments.length 为函数实参个数，arguments.callee 引用函数自身。 注意：在严格模式下，第 5 版 ECMAScript (ES5) 禁止使用 arguments.callee()。当一个函数必须调用自身的时候, 避免使用 arguments.callee(), 通过要么给函数表达式一个名字,要么使用一个函数声明. 特性：arguments 对象和 Function 是分不开的。因为 arguments 这个对象不能显式创建，arguments 对象只有函数开始时才可用。 使用方法：虽然 arguments 对象并不是一个数组，但是访问单个参数的方式与访问数组元素的方式相同 Array.prototype.slice.apply(arguments)用意直接调用 arguments.slice()将返回一个”Object doesn”t support this property or method”错误，因为 arguments 不是一个真正的数组。调用 Array.prototype.slice.apply(arguments)的意义就在于它能将函数的参数对象转化为一个真正的数组。 Array.prototype.slice.apply(arguments， [1])用意首先这段代码的目的是为了拿到参数里除第一个以外后面的所有参数。 现在 arguments 不是数组，所以不能直接调用 slice 方法，在 JavaScript 中借用其它对象的方法可以通过 apply 或者 call，以 call 为例，上述例子应该改写为： // 需要借用的方法slice在Array.prototype 上，然后call接受两个参数 // 第一个是需要借用方法的对象 // 第二个是传进方法的参数，也就是1 Array.prototype.slice.call(arguments, 1) // 也可以写成 [].slice.call(arguments, 1) apply 方法与 call 方法apply 方法与 call 方法是一样的，区别只是传参的形式，需要把方法参数按数组形式传进： Array.prototype.apply(arguments, [1]) // 数组传入 Array.prototype.apply(arguments, 1)","permalink":"https://blog.utone.xyz/2017110161300/","photos":[]},{"tags":[{"name":"Git","slug":"Git","permalink":"https://blog.utone.xyz/tags/Git/"},{"name":"SSH","slug":"SSH","permalink":"https://blog.utone.xyz/tags/SSH/"}],"title":"git生成ssh秘钥","date":"2017/10/20","text":"// 查看是否存在秘钥 $ cd ~/.ssh // 配置用户相关信息 $ git config –-global user.name ‘xxxxx’ $ git config –-global user.email ‘xxx@xx.xxx’ // 查看用户配置的相关信息 $ git config user.name $ git config user.email // 生成秘钥 (邮箱为上方配置的邮箱) $ ssh-keygen -t rsa -C ‘xxx@xx.xxx’ // 连按三个空格 Generating public/private rsa key pair. Enter file in which to save the key (/c/Users/Mr.Yang/.ssh/id_rsa): Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in /c/Users/Mr.Yang/.ssh/id_rsa. Your public key has been saved in /c/Users/Mr.Yang/.ssh/id_rsa.pub. The key fingerprint is: SHA256:zA6wNJrFB6NcqS6eBog/AHlzQuvFjYpG759Yhh1lWGI xxxxxx@xxxxx.xxx(上面自己的邮箱) The key\"s randomart image is: +---[RSA 2048]----+ | +E . | | ..+oo+ | | oo+*+.o | |o.*===+o | |==+*... S | |B.+.o .o | |++o. + . | | +o.+ . | |. o.o | +----[SHA256]-----+ ~/ .ssh 文件夹下，生成两个文件，id_rsa（私有秘钥）和 id_rsa.pub（公有密钥）d_rsa.pub（公有密钥）可上传至远端，免密 push","permalink":"https://blog.utone.xyz/2017102011568/","photos":[]},{"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://blog.utone.xyz/tags/JavaScript/"},{"name":"NodeJS","slug":"NodeJS","permalink":"https://blog.utone.xyz/tags/NodeJS/"},{"name":"Linux","slug":"Linux","permalink":"https://blog.utone.xyz/tags/Linux/"}],"title":"Linux安装NodeJS","date":"2017/10/18","text":"安装 NodeJS 首先下载 node 安装包，下载编译好的，下载完毕，解压后，直接软连接设置成全局，即可使用 #进入安装包放置的位置 cd /usr/local/src #下载安装包，这个是编译好的安装包，不要make &amp;&amp; make install wget https://nodejs.org/dist/v6.11.4/node-v6.11.4-linux-x64.tar.xz # 解压并进入 // 可能会报错（gzip: stdin: not in gzip format） 去掉z参数 tar -zxvf node-v6.11.4-linux-x64.tar.xz #软链接、设置成全局 ln -s /usr/local/src/node-v6.11.4-linux-x64/bin/node /usr/local/bin/node ln -s /usr/local/src/node-v6.11.4-linux-x64/bin/npm /usr/local/bin/npm #查看node版本 node -v 安装 Express 框架//首先安装马云爸爸的淘宝cnpm命令 npm install -g cnpm --registry=https://registry.npm.taobao.org //建立软链接 ln -s /usr/local/src/node-v6.11.4-linux-x64/bin/cnpm /usr/local/bin/cnpm // 先安装express-generator脚手架(新版本须装) cnpm install -g express-generator // 安装Express cnpm install -g express // 建立软链接 ln -s /usr/local/src/node-v6.11.4-linux-x64/bin/express /usr/local/bin/express // 创建项目 cd /project express app // 进入app项目，安装相关依赖 cnpm install // 启动node进程 npm start // 浏览器访问http://127.0.0.1:3000 Express欢迎页面呈现 安装 Forever 守护模块// https://github.com/foreverjs/forever // 可以使用Lniux命令，后台运行node服务 nohup npm start &amp;","permalink":"https://blog.utone.xyz/2017101841948/","photos":[]}]}